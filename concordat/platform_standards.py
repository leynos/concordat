"""Helpers for editing the platform-standards repository via PR."""

from __future__ import annotations

import dataclasses
import subprocess
import textwrap
import typing as typ
from pathlib import Path
from tempfile import TemporaryDirectory

import github3
import pygit2
from ruamel.yaml import YAML

from .errors import ConcordatError
from .gitutils import build_remote_callbacks


class _PullRequest(typ.Protocol):
    html_url: str


class _PullRequestRepository(typ.Protocol):
    def create_pull(
        self,
        title: str,
        *,
        base: str,
        head: str,
        body: str,
    ) -> _PullRequest: ...

    def pull_requests(
        self,
        *,
        state: str,
        head: str,
        base: str,
    ) -> typ.Iterable[_PullRequest]: ...


_yaml = YAML(typ="safe")
_yaml.default_flow_style = False
_yaml.explicit_start = False
_yaml.explicit_end = False
_yaml.indent(mapping=2, sequence=4, offset=2)
_yaml.sort_base_mapping_type_on_output = False

ERROR_MISSING_TOKEN = (
    "GITHUB_TOKEN is required to open the platform-standards pull request"  # noqa: S105
)
ERROR_SLUG = "Unable to determine GitHub slug from URL"


@dataclasses.dataclass
class PlatformStandardsConfig:
    """Configuration for interacting with the platform-standards repository."""

    repo_url: str
    base_branch: str = "main"
    inventory_path: str = "tofu/inventory/repositories.yaml"
    github_token: str | None = None


@dataclasses.dataclass(frozen=True)
class PlatformStandardsResult:
    """Outcome of attempting to open a platform-standards pull request."""

    created: bool
    branch: str | None
    pr_url: str | None
    message: str


def ensure_repository_pr(
    repo_slug: str,
    *,
    config: PlatformStandardsConfig,
) -> PlatformStandardsResult:
    """Clone platform-standards, add the repo to the inventory, and open a PR."""
    callbacks = build_remote_callbacks(config.repo_url)
    with TemporaryDirectory(prefix="concordat-platform-") as temp_root:
        repository = pygit2.clone_repository(
            config.repo_url,
            temp_root,
            callbacks=callbacks,
        )

        workdir = Path(repository.workdir or temp_root)
        branch_name = _branch_name_for(repo_slug)
        base_commit = _checkout_pr_branch(
            repository,
            callbacks=callbacks,
            base_branch=config.base_branch,
            branch_name=branch_name,
        )

        inventory_path = workdir / config.inventory_path
        added = _update_inventory(inventory_path, repo_slug)
        if not added:
            return PlatformStandardsResult(
                created=False,
                branch=branch_name,
                pr_url=None,
                message="repository already enrolled in inventory",
            )

        rel_inventory = str(Path(config.inventory_path))
        repository.index.add(rel_inventory)
        repository.index.write()

        try:
            signature = repository.default_signature
        except KeyError:
            signature = pygit2.Signature("concordat", "concordat@local")
        tree_oid = repository.index.write_tree()
        commit_message = f"chore: enrol {repo_slug} via concordat"
        repository.create_commit(
            "HEAD",
            signature,
            signature,
            commit_message,
            tree_oid,
            [base_commit.id],
        )

        _run_cmd(["tofu", "fmt", "-recursive", "tofu"], cwd=workdir)
        _run_cmd(["tofu", "fmt", "-recursive", "-check", "tofu"], cwd=workdir)
        _run_tflint(workdir)
        _run_tofo_validate(workdir)

        remote = repository.remotes["origin"]
        refspec = f"refs/heads/{branch_name}:refs/heads/{branch_name}"
        remote.push([refspec], callbacks=callbacks)

        if not config.github_token:
            raise ConcordatError(ERROR_MISSING_TOKEN)

        owner, name = _github_slug_from_url(config.repo_url)
        client = github3.login(token=config.github_token)
        gh_repo = client.repository(owner, name)
        pr_title = f"Concordat: enrol {repo_slug}"
        pr_body = textwrap.dedent(
            f"""
            This pull request was generated by `concordat enrol`.

            - adds `{repo_slug}` to `{config.inventory_path}`
            - ran `tofu fmt`, `tflint`, and `tofu validate` locally
            """
        ).strip()
        pr = _open_or_fetch_pull_request(
            gh_repo,
            owner=owner,
            title=pr_title,
            base=config.base_branch,
            head_branch=branch_name,
            body=pr_body,
        )

        return PlatformStandardsResult(
            created=True,
            branch=branch_name,
            pr_url=pr.html_url,
            message="opened platform-standards PR",
        )


def ensure_repository_removal_pr(
    repo_slug: str,
    *,
    config: PlatformStandardsConfig,
) -> PlatformStandardsResult:
    """Clone platform-standards, remove the repo from inventory, and open a PR."""
    callbacks = build_remote_callbacks(config.repo_url)
    with TemporaryDirectory(prefix="concordat-platform-") as temp_root:
        repository = pygit2.clone_repository(
            config.repo_url,
            temp_root,
            callbacks=callbacks,
        )

        workdir = Path(repository.workdir or temp_root)
        branch_name = _branch_name_for(repo_slug, verb="disenrol")
        base_commit = _checkout_pr_branch(
            repository,
            callbacks=callbacks,
            base_branch=config.base_branch,
            branch_name=branch_name,
        )

        inventory_path = workdir / config.inventory_path
        removed = _remove_inventory(inventory_path, repo_slug)
        if not removed:
            return PlatformStandardsResult(
                created=False,
                branch=branch_name,
                pr_url=None,
                message="repository already absent from inventory",
            )

        rel_inventory = str(Path(config.inventory_path))
        repository.index.add(rel_inventory)
        repository.index.write()

        try:
            signature = repository.default_signature
        except KeyError:
            signature = pygit2.Signature("concordat", "concordat@local")
        tree_oid = repository.index.write_tree()
        commit_message = f"chore: disenrol {repo_slug} via concordat"
        repository.create_commit(
            "HEAD",
            signature,
            signature,
            commit_message,
            tree_oid,
            [base_commit.id],
        )

        _run_cmd(["tofu", "fmt", "-recursive", "tofu"], cwd=workdir)
        _run_cmd(["tofu", "fmt", "-recursive", "-check", "tofu"], cwd=workdir)
        _run_tflint(workdir)
        _run_tofo_validate(workdir)

        remote = repository.remotes["origin"]
        refspec = f"refs/heads/{branch_name}:refs/heads/{branch_name}"
        remote.push([refspec], callbacks=callbacks)

        if not config.github_token:
            raise ConcordatError(ERROR_MISSING_TOKEN)

        owner, name = _github_slug_from_url(config.repo_url)
        client = github3.login(token=config.github_token)
        gh_repo = client.repository(owner, name)
        pr_title = f"Concordat: disenrol {repo_slug}"
        pr_body = textwrap.dedent(
            f"""
            This pull request was generated by `concordat disenrol`.

            - removes `{repo_slug}` from `{config.inventory_path}`
            - ran `tofu fmt`, `tflint`, and `tofu validate` locally
            """
        ).strip()
        pr = _open_or_fetch_pull_request(
            gh_repo,
            owner=owner,
            title=pr_title,
            base=config.base_branch,
            head_branch=branch_name,
            body=pr_body,
        )

        return PlatformStandardsResult(
            created=True,
            branch=branch_name,
            pr_url=pr.html_url,
            message="opened platform-standards PR",
        )


def _update_inventory(path: Path, repo_slug: str) -> bool:
    path.parent.mkdir(parents=True, exist_ok=True)
    data: dict[str, typ.Any]
    if path.exists():
        loaded = _yaml.load(path.read_text(encoding="utf-8")) or {}
        if isinstance(loaded, dict):
            data = dict(loaded)
        else:
            data = {"schema_version": 1, "repositories": []}
    else:
        data = {"schema_version": 1, "repositories": []}

    repos: list[dict[str, typ.Any]] = data.setdefault("repositories", [])
    names = {entry.get("name") for entry in repos}
    if repo_slug in names:
        return False
    repos.append({"name": repo_slug})
    repos.sort(key=lambda entry: str(entry.get("name", "")))

    schema_version = int(data.get("schema_version", 1) or 1)
    canonical: dict[str, typ.Any] = {
        "schema_version": schema_version,
        "repositories": repos,
    }
    for key, value in data.items():
        if key not in canonical:
            canonical[key] = value
    with path.open("w", encoding="utf-8") as handle:
        _yaml.dump(canonical, handle)
    return True


def _remove_inventory(path: Path, repo_slug: str) -> bool:
    """Remove a repository from the inventory file, returning True on change."""
    if not path.exists():
        return False

    loaded = _yaml.load(path.read_text(encoding="utf-8")) or {}
    if not isinstance(loaded, dict):
        return False

    data: dict[str, typ.Any] = dict(loaded)
    repos_raw = data.get("repositories") or []
    if not isinstance(repos_raw, list):
        return False

    repos: list[dict[str, typ.Any]] = [
        entry for entry in repos_raw if isinstance(entry, dict)
    ]
    before = len(repos)
    repos = [entry for entry in repos if entry.get("name") != repo_slug]
    if len(repos) == before:
        return False

    repos.sort(key=lambda entry: str(entry.get("name", "")))

    schema_version = int(data.get("schema_version", 1) or 1)
    canonical: dict[str, typ.Any] = {
        "schema_version": schema_version,
        "repositories": repos,
    }
    for key, value in data.items():
        if key not in canonical:
            canonical[key] = value
    with path.open("w", encoding="utf-8") as handle:
        _yaml.dump(canonical, handle)
    return True


def _run_cmd(args: list[str], *, cwd: Path) -> None:
    subprocess.run(  # noqa: S603
        args,
        check=True,
        cwd=str(cwd),
        capture_output=False,
    )


def _run_tflint(workdir: Path) -> None:
    modules_dir = workdir / "tofu" / "modules"
    if not modules_dir.exists():
        return
    for module in sorted(d for d in modules_dir.iterdir() if d.is_dir()):
        _run_cmd(["tflint", f"--chdir={module}"], cwd=workdir)


def _run_tofo_validate(workdir: Path) -> None:
    modules_dir = workdir / "tofu" / "modules"
    if not modules_dir.exists():
        return
    for module in sorted(d for d in modules_dir.iterdir() if d.is_dir()):
        _run_cmd(["tofu", "init", "-backend=false"], cwd=module)
        _run_cmd(["tofu", "validate"], cwd=module)


def _github_slug_from_url(url: str) -> tuple[str, str]:
    slug = parse_github_slug(url)
    if not slug:
        raise ConcordatError(ERROR_SLUG)
    owner, name = slug.split("/", 1)
    return owner, name


def parse_github_slug(url: str) -> str | None:
    """Return the GitHub owner/repo slug for common remote URL formats."""
    stripped = url.rstrip(".git")
    if stripped.startswith("git@github.com:"):
        return stripped.split("git@github.com:", 1)[1]
    if stripped.startswith("https://github.com/"):
        return stripped.split("https://github.com/", 1)[1]
    if stripped.startswith("ssh://git@github.com/"):
        return stripped.split("ssh://git@github.com/", 1)[1]
    return None


def _branch_name_for(slug: str, *, verb: str = "enrol") -> str:
    safe = slug.replace("/", "-")
    return f"concordat/{verb}/{safe}"


def _checkout_pr_branch(
    repository: pygit2.Repository,
    *,
    callbacks: pygit2.RemoteCallbacks | None,
    base_branch: str,
    branch_name: str,
) -> pygit2.Commit:
    """Checkout a local work branch, reusing an existing remote branch if present.

    When a prior concordat run already pushed the branch, recreating it from the
    base branch can lead to non-fast-forward push failures. Reusing the remote
    branch keeps the push linear and updates any existing PR.
    """
    remote = repository.remotes["origin"]
    remote.fetch(callbacks=callbacks)

    remote_branch_name = f"origin/{branch_name}"
    try:
        remote_branch = repository.branches.remote[remote_branch_name]
    except KeyError:
        remote_branch = None

    if remote_branch is not None:
        base_ref = remote_branch
    else:
        base_ref = repository.branches[base_branch]
    base_commit = base_ref.peel(pygit2.Commit)

    if branch_name in repository.branches.local:
        repository.branches.delete(branch_name)
    new_branch = repository.create_branch(branch_name, base_commit)
    repository.checkout(new_branch)
    return base_commit


def _open_or_fetch_pull_request(
    gh_repo: _PullRequestRepository,
    *,
    owner: str,
    title: str,
    base: str,
    head_branch: str,
    body: str,
) -> _PullRequest:
    """Create a pull request, or return the existing one for the same head."""
    github3_exceptions = getattr(github3, "exceptions", None)
    unprocessable = getattr(github3_exceptions, "UnprocessableEntity", Exception)

    try:
        return gh_repo.create_pull(
            title,
            base=base,
            head=head_branch,
            body=body,
        )
    except unprocessable:
        head = f"{owner}:{head_branch}"
        for pr in gh_repo.pull_requests(state="open", head=head, base=base):
            return pr
        raise
