"""Helpers for editing the platform-standards repository via PR."""

from __future__ import annotations

import dataclasses
import subprocess
import textwrap
import typing as typ
from pathlib import Path
from tempfile import TemporaryDirectory

import github3
import pygit2
from ruamel.yaml import YAML

from .errors import ConcordatError
from .gitutils import build_remote_callbacks

_yaml = YAML(typ="safe")
_yaml.default_flow_style = False
_yaml.explicit_start = False
_yaml.explicit_end = False
_yaml.indent(mapping=2, sequence=4, offset=2)
_yaml.sort_base_mapping_type_on_output = False

ERROR_MISSING_TOKEN = (
    "GITHUB_TOKEN is required to open the platform-standards pull request"  # noqa: S105
)
ERROR_SLUG = "Unable to determine GitHub slug from URL"


@dataclasses.dataclass
class PlatformStandardsConfig:
    """Configuration for interacting with the platform-standards repository."""

    repo_url: str
    base_branch: str = "main"
    inventory_path: str = "tofu/inventory/repositories.yaml"
    github_token: str | None = None


@dataclasses.dataclass(frozen=True)
class PlatformStandardsResult:
    """Outcome of attempting to open a platform-standards pull request."""

    created: bool
    branch: str | None
    pr_url: str | None
    message: str


def ensure_repository_pr(
    repo_slug: str,
    *,
    config: PlatformStandardsConfig,
) -> PlatformStandardsResult:
    """Clone platform-standards, add the repo to the inventory, and open a PR."""
    callbacks = build_remote_callbacks(config.repo_url)
    with TemporaryDirectory(prefix="concordat-platform-") as temp_root:
        repository = pygit2.clone_repository(
            config.repo_url,
            temp_root,
            callbacks=callbacks,
        )

        workdir = Path(repository.workdir or temp_root)
        inventory_path = workdir / config.inventory_path
        added = _update_inventory(inventory_path, repo_slug)
        if not added:
            return PlatformStandardsResult(
                created=False,
                branch=None,
                pr_url=None,
                message="repository already enrolled in inventory",
            )

        rel_inventory = str(Path(config.inventory_path))
        repository.index.add(rel_inventory)
        repository.index.write()

        base_branch = repository.branches[config.base_branch]
        base_commit = base_branch.peel(pygit2.Commit)
        branch_name = _branch_name_for(repo_slug)
        if branch_name in repository.branches.local:
            repository.branches.delete(branch_name)
        new_branch = repository.create_branch(branch_name, base_commit)
        repository.checkout(new_branch)

        try:
            signature = repository.default_signature
        except KeyError:
            signature = pygit2.Signature("concordat", "concordat@local")
        tree_oid = repository.index.write_tree()
        commit_message = f"chore: enrol {repo_slug} via concordat"
        repository.create_commit(
            "HEAD",
            signature,
            signature,
            commit_message,
            tree_oid,
            [base_commit.id],
        )

        _run_cmd(["tofu", "fmt", "-recursive", "tofu"], cwd=workdir)
        _run_cmd(["tofu", "fmt", "-recursive", "-check", "tofu"], cwd=workdir)
        _run_tflint(workdir)
        _run_tofo_validate(workdir)

        remote = repository.remotes["origin"]
        refspec = f"refs/heads/{branch_name}:refs/heads/{branch_name}"
        remote.push([refspec], callbacks=callbacks)

        if not config.github_token:
            raise ConcordatError(ERROR_MISSING_TOKEN)

        owner, name = _github_slug_from_url(config.repo_url)
        client = github3.login(token=config.github_token)
        gh_repo = client.repository(owner, name)
        pr_title = f"Concordat: enrol {repo_slug}"
        pr_body = textwrap.dedent(
            f"""
            This pull request was generated by `concordat enrol`.

            - adds `{repo_slug}` to `{config.inventory_path}`
            - ran `tofu fmt`, `tflint`, and `tofu validate` locally
            """
        ).strip()
        pr = gh_repo.create_pull(
            pr_title,
            base=config.base_branch,
            head=branch_name,
            body=pr_body,
        )

        return PlatformStandardsResult(
            created=True,
            branch=branch_name,
            pr_url=pr.html_url,
            message="opened platform-standards PR",
        )


def _update_inventory(path: Path, repo_slug: str) -> bool:
    path.parent.mkdir(parents=True, exist_ok=True)
    data: dict[str, typ.Any]
    if path.exists():
        loaded = _yaml.load(path.read_text(encoding="utf-8")) or {}
        if isinstance(loaded, dict):
            data = dict(loaded)
        else:
            data = {"schema_version": 1, "repositories": []}
    else:
        data = {"schema_version": 1, "repositories": []}

    repos: list[dict[str, typ.Any]] = data.setdefault("repositories", [])
    names = {entry.get("name") for entry in repos}
    if repo_slug in names:
        return False
    repos.append({"name": repo_slug})
    repos.sort(key=lambda entry: str(entry.get("name", "")))

    schema_version = int(data.get("schema_version", 1) or 1)
    canonical: dict[str, typ.Any] = {
        "schema_version": schema_version,
        "repositories": repos,
    }
    for key, value in data.items():
        if key not in canonical:
            canonical[key] = value
    with path.open("w", encoding="utf-8") as handle:
        _yaml.dump(canonical, handle)
    return True


def _run_cmd(args: list[str], *, cwd: Path) -> None:
    subprocess.run(  # noqa: S603
        args,
        check=True,
        cwd=str(cwd),
        capture_output=False,
    )


def _run_tflint(workdir: Path) -> None:
    modules_dir = workdir / "tofu" / "modules"
    if not modules_dir.exists():
        return
    for module in sorted(d for d in modules_dir.iterdir() if d.is_dir()):
        _run_cmd(["tflint", f"--chdir={module}"], cwd=workdir)


def _run_tofo_validate(workdir: Path) -> None:
    modules_dir = workdir / "tofu" / "modules"
    if not modules_dir.exists():
        return
    for module in sorted(d for d in modules_dir.iterdir() if d.is_dir()):
        _run_cmd(["tofu", "init", "-backend=false"], cwd=module)
        _run_cmd(["tofu", "validate"], cwd=module)


def _github_slug_from_url(url: str) -> tuple[str, str]:
    slug = parse_github_slug(url)
    if not slug:
        raise ConcordatError(ERROR_SLUG)
    owner, name = slug.split("/", 1)
    return owner, name


def parse_github_slug(url: str) -> str | None:
    """Return the GitHub owner/repo slug for common remote URL formats."""
    stripped = url.rstrip(".git")
    if stripped.startswith("git@github.com:"):
        return stripped.split("git@github.com:", 1)[1]
    if stripped.startswith("https://github.com/"):
        return stripped.split("https://github.com/", 1)[1]
    if stripped.startswith("ssh://git@github.com/"):
        return stripped.split("ssh://git@github.com/", 1)[1]
    return None


def _branch_name_for(slug: str) -> str:
    safe = slug.replace("/", "-")
    return f"concordat/enrol/{safe}"
