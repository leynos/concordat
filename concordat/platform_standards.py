"""Helpers for editing the platform-standards repository via PR."""

from __future__ import annotations

import dataclasses
import subprocess
import textwrap
import typing as typ
from pathlib import Path
from tempfile import TemporaryDirectory

import github3
import pygit2
from ruamel.yaml import YAML

from .errors import ConcordatError
from .gitutils import build_remote_callbacks


class _PullRequest(typ.Protocol):
    html_url: str


class _PullRequestRepository(typ.Protocol):
    def create_pull(
        self,
        title: str,
        *,
        base: str,
        head: str,
        body: str,
    ) -> _PullRequest: ...

    def pull_requests(
        self,
        *,
        state: str,
        head: str,
        base: str,
    ) -> typ.Iterable[_PullRequest]: ...


_yaml = YAML(typ="safe")
_yaml.default_flow_style = False
_yaml.explicit_start = False
_yaml.explicit_end = False
_yaml.indent(mapping=2, sequence=4, offset=2)
_yaml.sort_base_mapping_type_on_output = False

ERROR_MISSING_TOKEN = (
    "GITHUB_TOKEN is required to open the platform-standards pull request"  # noqa: S105
)
ERROR_SLUG = "Unable to determine GitHub slug from URL"


@dataclasses.dataclass
class PlatformStandardsConfig:
    """Configuration for interacting with the platform-standards repository."""

    repo_url: str
    base_branch: str = "main"
    inventory_path: str = "tofu/inventory/repositories.yaml"
    github_token: str | None = None


@dataclasses.dataclass(frozen=True)
class PlatformStandardsResult:
    """Outcome of attempting to open a platform-standards pull request."""

    created: bool
    branch: str | None
    pr_url: str | None
    message: str


def _check_base_branch_enrollment(
    repository: pygit2.Repository,
    config: PlatformStandardsConfig,
    repo_slug: str,
    branch_name: str,
    *,
    expect_present: bool,
) -> PlatformStandardsResult | None:
    """Check if repo enrollment state matches expectation in base branch.

    Args:
        repository: The pygit2 repository object.
        config: Platform standards configuration.
        repo_slug: Repository slug to check.
        branch_name: Branch name for the result.
        expect_present: If True, return early when present; if False, when absent.

    Returns:
        PlatformStandardsResult if already in expected state, None otherwise.

    """
    base_branch_commit = _resolve_branch_commit(repository, config.base_branch)
    base_slugs = _inventory_slugs_from_commit(
        repository,
        base_branch_commit,
        inventory_path=config.inventory_path,
    )
    is_present = repo_slug in base_slugs

    if expect_present and is_present:
        return PlatformStandardsResult(
            created=False,
            branch=branch_name,
            pr_url=None,
            message="repository already enrolled in inventory",
        )
    if not expect_present and not is_present:
        return PlatformStandardsResult(
            created=False,
            branch=branch_name,
            pr_url=None,
            message="repository already absent from inventory",
        )
    return None


def _create_pr_for_inventory_change(
    config: PlatformStandardsConfig,
    repo_slug: str,
    branch_name: str,
    *,
    verb: str,
) -> tuple[str, str]:
    """Create or fetch a platform-standards PR for inventory change.

    Args:
        config: Platform standards configuration.
        repo_slug: Repository slug being changed.
        branch_name: Branch name for the PR.
        verb: Action verb ("enrol" or "disenrol").

    Returns:
        Tuple of (pr_url, message).

    """
    owner, name = _github_slug_from_url(config.repo_url)
    client = github3.login(token=config.github_token)
    gh_repo = client.repository(owner, name)
    pr_title = f"Concordat: {verb} {repo_slug}"
    action = "adds" if verb == "enrol" else "removes"
    preposition = "to" if verb == "enrol" else "from"
    pr_body = textwrap.dedent(f"""
        This pull request was generated by `concordat {verb}`.

        - {action} `{repo_slug}` {preposition} `{config.inventory_path}`
        - ran `tofu fmt`, `tflint`, and `tofu validate` locally
        """).strip()
    pr = _open_or_fetch_pull_request(
        gh_repo,
        owner=owner,
        title=pr_title,
        base=config.base_branch,
        head_branch=branch_name,
        body=pr_body,
    )
    return (pr.html_url, "platform-standards PR already open")


def _handle_existing_remote_branch(
    repository: pygit2.Repository,
    config: PlatformStandardsConfig,
    repo_slug: str,
    branch_name: str,
    *,
    expect_present: bool,
    verb: str,
) -> PlatformStandardsResult | None:
    """Check if remote branch exists with expected change; create/fetch PR if so.

    Args:
        repository: The pygit2 repository object.
        config: Platform standards configuration.
        repo_slug: Repository slug to check.
        branch_name: Branch name to check.
        expect_present: If True (enrol), slug present; if False (disenrol), absent.
        verb: Action verb ("enrol" or "disenrol").

    Returns:
        PlatformStandardsResult if branch exists with change, None otherwise.

    """
    remote_branch_commit = _resolve_remote_branch_commit(repository, branch_name)
    if remote_branch_commit is None:
        return None

    branch_slugs = _inventory_slugs_from_commit(
        repository,
        remote_branch_commit,
        inventory_path=config.inventory_path,
    )
    is_present = repo_slug in branch_slugs

    # For enrol: expect_present=True, we want slug present on branch
    # For disenrol: expect_present=False, we want slug absent on branch
    if expect_present and not is_present:
        return None
    if not expect_present and is_present:
        return None

    pr_url = None
    message = (
        "inventory change already present on branch; "
        "merge the existing platform-standards PR"
    )
    if config.github_token:
        pr_url, message = _create_pr_for_inventory_change(
            config, repo_slug, branch_name, verb=verb
        )

    return PlatformStandardsResult(
        created=True,
        branch=branch_name,
        pr_url=pr_url,
        message=message,
    )


def _commit_inventory_changes(
    repository: pygit2.Repository,
    config: PlatformStandardsConfig,
    repo_slug: str,
    base_commit: pygit2.Commit,
    *,
    verb: str,
) -> None:
    """Add inventory file to index and create commit.

    Args:
        repository: The pygit2 repository object.
        config: Platform standards configuration.
        repo_slug: Repository slug being changed.
        base_commit: The base commit to create the new commit on.
        verb: Action verb ("enrol" or "disenrol").

    """
    rel_inventory = str(Path(config.inventory_path))
    repository.index.add(rel_inventory)
    repository.index.write()

    try:
        signature = repository.default_signature
    except KeyError:
        signature = pygit2.Signature("concordat", "concordat@local")

    tree_oid = repository.index.write_tree()
    commit_message = f"chore: {verb} {repo_slug} via concordat"
    repository.create_commit(
        "HEAD",
        signature,
        signature,
        commit_message,
        tree_oid,
        [base_commit.id],
    )


def _validate_tofu_changes(workdir: Path) -> None:
    """Run tofu fmt, tflint, and tofu validate on changes."""
    _run_cmd(["tofu", "fmt", "-recursive", "tofu"], cwd=workdir)
    _run_cmd(["tofu", "fmt", "-recursive", "-check", "tofu"], cwd=workdir)
    _run_tflint(workdir)
    _run_tofo_validate(workdir)


def ensure_repository_pr(
    repo_slug: str,
    *,
    config: PlatformStandardsConfig,
) -> PlatformStandardsResult:
    """Clone platform-standards, add the repo to the inventory, and open a PR."""
    callbacks = build_remote_callbacks(config.repo_url)
    with TemporaryDirectory(prefix="concordat-platform-") as temp_root:
        repository = pygit2.clone_repository(
            config.repo_url,
            temp_root,
            callbacks=callbacks,
        )

        workdir = Path(repository.workdir or temp_root)
        remote = repository.remotes["origin"]
        remote.fetch(callbacks=callbacks)

        branch_name = _branch_name_for(repo_slug)

        if result := _check_base_branch_enrollment(
            repository, config, repo_slug, branch_name, expect_present=True
        ):
            return result

        if result := _handle_existing_remote_branch(
            repository,
            config,
            repo_slug,
            branch_name,
            expect_present=True,
            verb="enrol",
        ):
            return result

        base_commit = _checkout_pr_branch(
            repository,
            callbacks=callbacks,
            base_branch=config.base_branch,
            branch_name=branch_name,
        )

        inventory_path = workdir / config.inventory_path
        added = _update_inventory(inventory_path, repo_slug)
        if not added:
            return PlatformStandardsResult(
                created=False,
                branch=branch_name,
                pr_url=None,
                message="repository already enrolled in inventory",
            )

        _commit_inventory_changes(
            repository, config, repo_slug, base_commit, verb="enrol"
        )
        _validate_tofu_changes(workdir)

        refspec = f"refs/heads/{branch_name}:refs/heads/{branch_name}"
        remote.push([refspec], callbacks=callbacks)

        if not config.github_token:
            raise ConcordatError(ERROR_MISSING_TOKEN)

        pr_url, _ = _create_pr_for_inventory_change(
            config, repo_slug, branch_name, verb="enrol"
        )

        return PlatformStandardsResult(
            created=True,
            branch=branch_name,
            pr_url=pr_url,
            message="opened platform-standards PR",
        )


def ensure_repository_removal_pr(
    repo_slug: str,
    *,
    config: PlatformStandardsConfig,
) -> PlatformStandardsResult:
    """Clone platform-standards, remove the repo from inventory, and open a PR."""
    callbacks = build_remote_callbacks(config.repo_url)
    with TemporaryDirectory(prefix="concordat-platform-") as temp_root:
        repository = pygit2.clone_repository(
            config.repo_url,
            temp_root,
            callbacks=callbacks,
        )

        workdir = Path(repository.workdir or temp_root)
        remote = repository.remotes["origin"]
        remote.fetch(callbacks=callbacks)

        branch_name = _branch_name_for(repo_slug, verb="disenrol")

        if result := _check_base_branch_enrollment(
            repository, config, repo_slug, branch_name, expect_present=False
        ):
            return result

        if result := _handle_existing_remote_branch(
            repository,
            config,
            repo_slug,
            branch_name,
            expect_present=False,
            verb="disenrol",
        ):
            return result

        base_commit = _checkout_pr_branch(
            repository,
            callbacks=callbacks,
            base_branch=config.base_branch,
            branch_name=branch_name,
        )

        inventory_path = workdir / config.inventory_path
        removed = _remove_inventory(inventory_path, repo_slug)
        if not removed:
            return PlatformStandardsResult(
                created=False,
                branch=branch_name,
                pr_url=None,
                message="repository already absent from inventory",
            )

        _commit_inventory_changes(
            repository, config, repo_slug, base_commit, verb="disenrol"
        )
        _validate_tofu_changes(workdir)

        refspec = f"refs/heads/{branch_name}:refs/heads/{branch_name}"
        remote.push([refspec], callbacks=callbacks)

        if not config.github_token:
            raise ConcordatError(ERROR_MISSING_TOKEN)

        pr_url, _ = _create_pr_for_inventory_change(
            config, repo_slug, branch_name, verb="disenrol"
        )

        return PlatformStandardsResult(
            created=True,
            branch=branch_name,
            pr_url=pr_url,
            message="opened platform-standards PR",
        )


def _load_inventory_data(path: Path) -> dict[str, typ.Any]:
    """Load inventory data from file, returning a normalized dict structure.

    Always returns a dict with at least schema_version and repositories keys,
    even if the file doesn't exist or contains invalid data.

    """
    if not path.exists():
        return {"schema_version": 1, "repositories": []}

    loaded = _yaml.load(path.read_text(encoding="utf-8")) or {}
    if isinstance(loaded, dict):
        return dict(loaded)

    return {"schema_version": 1, "repositories": []}


def _build_canonical_inventory(
    data: dict[str, typ.Any],
    repos: list[dict[str, typ.Any]],
) -> dict[str, typ.Any]:
    """Build canonical inventory dict with schema_version and repositories first.

    Preserves any extra keys from the original data that aren't in the base structure.

    """
    schema_version = int(data.get("schema_version", 1) or 1)
    canonical: dict[str, typ.Any] = {
        "schema_version": schema_version,
        "repositories": repos,
    }
    for key, value in data.items():
        if key not in canonical:
            canonical[key] = value
    return canonical


def _update_inventory(path: Path, repo_slug: str) -> bool:
    path.parent.mkdir(parents=True, exist_ok=True)

    data = _load_inventory_data(path)

    repos: list[dict[str, typ.Any]] = data.setdefault("repositories", [])
    names = {entry.get("name") for entry in repos}
    if repo_slug in names:
        return False

    repos.append({"name": repo_slug})
    repos.sort(key=lambda entry: str(entry.get("name", "")))

    canonical = _build_canonical_inventory(data, repos)

    with path.open("w", encoding="utf-8") as handle:
        _yaml.dump(canonical, handle)
    return True


def _load_and_validate_inventory_data(path: Path) -> dict[str, typ.Any] | None:
    """Load and validate inventory file structure, returning data or None.

    Returns:
        Dictionary with inventory data if valid, None if file missing or invalid.

    """
    if not path.exists():
        return None

    loaded = _yaml.load(path.read_text(encoding="utf-8")) or {}
    if not isinstance(loaded, dict):
        return None

    return dict(loaded)


def _filter_repository_entries(
    repos_raw: object,
    repo_slug: str,
) -> tuple[list[dict[str, typ.Any]], bool]:
    """Filter repository list to remove the target slug.

    Args:
        repos_raw: Raw repositories value from YAML (may be any type).
        repo_slug: Repository slug to remove.

    Returns:
        Tuple of (filtered_list, changed) where changed is True if removed.

    """
    if not isinstance(repos_raw, list):
        return ([], False)

    repos: list[dict[str, typ.Any]] = [
        entry for entry in repos_raw if isinstance(entry, dict)
    ]  # type: ignore[misc]
    before = len(repos)
    repos = [entry for entry in repos if entry.get("name") != repo_slug]
    changed = len(repos) < before

    if not changed:
        return (repos, False)

    repos.sort(key=lambda entry: str(entry.get("name", "")))
    return (repos, True)


def _remove_inventory(path: Path, repo_slug: str) -> bool:
    """Remove a repository from the inventory file, returning True on change."""
    data = _load_and_validate_inventory_data(path)
    if data is None:
        return False

    repos_raw = data.get("repositories") or []
    repos, changed = _filter_repository_entries(repos_raw, repo_slug)
    if not changed:
        return False

    canonical = _build_canonical_inventory(data, repos)

    with path.open("w", encoding="utf-8") as handle:
        _yaml.dump(canonical, handle)
    return True


def _run_cmd(args: list[str], *, cwd: Path) -> None:
    subprocess.run(  # noqa: S603
        args,
        check=True,
        cwd=str(cwd),
        capture_output=False,
    )


def _run_tflint(workdir: Path) -> None:
    modules_dir = workdir / "tofu" / "modules"
    if not modules_dir.exists():
        return
    for module in sorted(d for d in modules_dir.iterdir() if d.is_dir()):
        _run_cmd(["tflint", f"--chdir={module}"], cwd=workdir)


def _run_tofo_validate(workdir: Path) -> None:
    modules_dir = workdir / "tofu" / "modules"
    if not modules_dir.exists():
        return
    for module in sorted(d for d in modules_dir.iterdir() if d.is_dir()):
        _run_cmd(["tofu", "init", "-backend=false"], cwd=module)
        _run_cmd(["tofu", "validate"], cwd=module)


def _github_slug_from_url(url: str) -> tuple[str, str]:
    slug = parse_github_slug(url)
    if not slug:
        raise ConcordatError(ERROR_SLUG)
    owner, name = slug.split("/", 1)
    return owner, name


def parse_github_slug(url: str) -> str | None:
    """Return the GitHub owner/repo slug for common remote URL formats."""
    stripped = url.strip().removesuffix(".git")
    if stripped.startswith("git@github.com:"):
        return stripped.split("git@github.com:", 1)[1]
    if stripped.startswith("https://github.com/"):
        return stripped.split("https://github.com/", 1)[1]
    if stripped.startswith("ssh://git@github.com/"):
        return stripped.split("ssh://git@github.com/", 1)[1]
    return None


def _branch_name_for(slug: str, *, verb: str = "enrol") -> str:
    safe = slug.replace("/", "-")
    return f"concordat/{verb}/{safe}"


def _resolve_branch_commit(
    repository: pygit2.Repository, branch_name: str
) -> pygit2.Commit:
    """Return the commit for either a local or remote branch reference."""
    try:
        branch = repository.branches[branch_name]
    except KeyError:
        remote_name = f"origin/{branch_name}"
        branch = repository.branches.remote[remote_name]
    return branch.peel(pygit2.Commit)


def _resolve_remote_branch_commit(
    repository: pygit2.Repository,
    branch_name: str,
) -> pygit2.Commit | None:
    remote_name = f"origin/{branch_name}"
    try:
        branch = repository.branches.remote[remote_name]
    except KeyError:
        return None
    return branch.peel(pygit2.Commit)


def _inventory_slugs_from_commit(
    repository: pygit2.Repository,
    commit: pygit2.Commit,
    *,
    inventory_path: str,
) -> set[str]:
    """Extract the inventory slugs from a specific commit."""
    try:
        entry = commit.tree[inventory_path]
    except KeyError:
        return set()
    blob = repository[entry.id]
    if not isinstance(blob, pygit2.Blob):
        return set()
    loaded = _yaml.load(blob.data.decode("utf-8")) or {}
    if not isinstance(loaded, dict):
        return set()
    repos = loaded.get("repositories") or []
    if not isinstance(repos, list):
        return set()
    slugs: set[str] = set()
    for item in repos:
        if not isinstance(item, dict):
            continue
        name = item.get("name")
        if isinstance(name, str) and name.strip():
            slugs.add(name.strip())
    return slugs


def _checkout_pr_branch(
    repository: pygit2.Repository,
    *,
    callbacks: pygit2.RemoteCallbacks | None,
    base_branch: str,
    branch_name: str,
) -> pygit2.Commit:
    """Checkout a local work branch, reusing an existing remote branch if present.

    When a prior concordat run already pushed the branch, recreating it from the
    base branch can lead to non-fast-forward push failures. Reusing the remote
    branch keeps the push linear and updates any existing PR.
    """
    remote = repository.remotes["origin"]
    remote.fetch(callbacks=callbacks)

    remote_branch_name = f"origin/{branch_name}"
    try:
        remote_branch = repository.branches.remote[remote_branch_name]
    except KeyError:
        remote_branch = None

    if remote_branch is not None:
        base_ref = remote_branch
    else:
        base_ref = repository.branches[base_branch]
    base_commit = base_ref.peel(pygit2.Commit)

    if branch_name in repository.branches.local:
        repository.branches.delete(branch_name)
    new_branch = repository.create_branch(branch_name, base_commit)
    repository.checkout(new_branch)
    return base_commit


def _open_or_fetch_pull_request(
    gh_repo: _PullRequestRepository,
    *,
    owner: str,
    title: str,
    base: str,
    head_branch: str,
    body: str,
) -> _PullRequest:
    """Create a pull request, or return the existing one for the same head."""
    github3_exceptions = getattr(github3, "exceptions", None)
    unprocessable = getattr(github3_exceptions, "UnprocessableEntity", Exception)

    try:
        return gh_repo.create_pull(
            title,
            base=base,
            head=head_branch,
            body=body,
        )
    except unprocessable:
        head = f"{owner}:{head_branch}"
        for pr in gh_repo.pull_requests(state="open", head=head, base=base):
            return pr
        raise
