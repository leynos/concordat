# Design document: GitHub estate standards and audit framework

## 1. System architecture and principles

This document specifies the design of a comprehensive framework for the
automated audit and enforcement of engineering standards across a large-scale
GitHub organization. It provides a definitive implementation blueprint for the
engineering team tasked with its construction, covering the complete system
architecture, detailed component specifications, data models, interfaces,
enforcement logic, and a practical, phased implementation strategy.

### 1.1. Overview, and core philosophy

The framework's central tenet is **"Standards as Code"**: the practice of
defining, versioning, and enforcing engineering standards through
machine-readable files stored in a version control system. This approach
transforms governance from a manual, documentation-driven process into an
automated system that remains testable while also being auditable, reducing
toil, and ensuring consistent application of best practices.

This philosophy is supported by three foundational pillars:

1. **Declarative State:** All target configurations for the GitHub estate,
   including repository settings, branch protections, and team permissions, are
   defined declaratively using Infrastructure as Code (IaC) principles. This
   provides a single source of truth for the desired state of the organization.
1. **Centralized Policy, and Audit:** A single, authoritative "Auditor" engine
   evaluates the compliance of every repository against a central,
   version-controlled set of policies and canonical configurations. This ensures
   that standards are applied uniformly and that the definition of "compliance"
   is transparent and unambiguous.
1. **Automated Enforcement and Remediation:** Compliance is rendered
   non-optional through automated gates integrated directly into the development
   lifecycle. Deviations from the declared state are automatically detected, and
   tooling is provided for efficient, scaled remediation, shifting the
   enforcement mechanism from human review to automated system validation.

Continuous integration (CI) and continuous delivery (CD) automation provide the
enforcement surface for these standards; the document references both terms
frequently when describing guardrails and feedback loops.

### 1.2. Architectural blueprint and data flow

The system is a composite architecture comprising several specialized,
interacting components. The data flow is designed to create a continuous loop of
declaration, audit, and enforcement.

The primary components, and their interactions are as follows:

1. **`platform-standards` repository:** This Git repository serves as the
   canonical source of truth for the entire framework. It contains all policy
   definitions, canonical file templates, reusable automation workflows, and the
   declarative configuration for the GitHub estate itself.
1. **Target repository:** Any repository within the organization that is subject
   to the framework's governance. It contains its own application code,
   project-specific documentation, and a crucial `.concordat` manifest that
   declares its characteristics and, via `enrolled: true`, opts into specific
   sets of standards.
1. **OpenTofu execution environment:** A secure, automated environment,
   typically a GitHub Actions runner, responsible for executing the OpenTofu IaC
   tool. On a recurring schedule, it runs `tofu plan` to compare the declared
   state in the `platform-standards` repository against the actual state of the
   GitHub organization reported by the GitHub Application Programming Interface
   (API). This process detects configuration drift. Upon approval, it can run
   `tofu apply` to reconcile the actual state with the desired state.
1. **Auditor engine:** A custom GitHub Action that serves as the core evaluation
   component. It runs both on a schedule across all repositories and on every
   pull request against a protected branch. The Auditor fetches content from the
   target repository, reads its `.concordat` manifest, and queries the GitHub
   API for settings. It then evaluates this collected data against the policies
   and canonical files sourced from a pinned version of the `platform-standards`
   repository.
1. **GitHub API:** The programmatic interface to GitHub, serving as the medium
   for both configuration management (via the OpenTofu provider), and state
   inspection (via the Auditor).
1. **GitHub code scanning interface:** The destination for all findings
   generated by the Auditor. The Auditor formats its output as a single Static
   Analysis Results Interchange Format (SARIF) file. When uploaded, these
   findings are natively integrated into the GitHub user interface, appearing in
   the "Security" tab, and as inline annotations on pull requests.
1. **`multi-gitter` execution environment:** An operator-triggered or automated
   environment for executing the `multi-gitter` tool. This component is used to
   dispatch mass pull requests across the repository estate to remediate
   content-level non-compliance at scale, such as rolling out an updated linter
   configuration file.

## 2. Canonical priority management

### 2.1 Motivation, and scope

Priority signals—labels on issues and the corresponding single-select fields in
Projects v2—drive incident response for Concordat repositories. Inconsistent
naming, colouring, or semantics across repositories diminishes routing
reliability while obscuring metrics. To align priority management with the
"standards as code" philosophy, the architecture introduces a canonical priority
model defined once in `platform-standards`. OpenTofu applies the model, and the
Auditor alongside GitHub rulesets enforces it. The `concordat` command-line
interface (CLI) remains the entry point for estate inventory and enrollment but
continues to defer all mutation to declarative automation.

### 2.2 Canonical priority model contract

The single source of truth for priority metadata lives under
`platform-standards/canon/priorities/priority-model.yaml`. This YAML contract
defines:

- The set of labels (`key`, exact `name`, GitHub hex `color`, and
  `description`).
- The organization-wide Projects v2 "Priority" field (name, type, allowed
  options).
- Optional `aliases` that map historical label names into the canonical keys.

All downstream automation pins to a tagged version of this file, ensuring
auditable changes while enabling staged rollouts. The Auditor action loads this
manifest at runtime (defaulting to the repository copy) so deviations surface
immediately as SARIF findings even before OpenTofu applies corrections.

### 2.3 OpenTofu modules for application

Two reusable modules extend `platform-standards/tofu`:

1. `modules/repo-priority-labels` — accepts a repository name, and the parsed
   priority model. It creates or updates the canonical `priority/*` labels using
   `github_issue_label` resources, removes deprecated labels when `aliases`
   indicate replacement, and operates across an entire repository map via
   `for_each`. This module is idempotent, and captured in nightly `tofu plan`
   drift reports.

1. `modules/projects-v2-priority-field` — ensures that every targeted Projects
   v2 board exposes a single-select "Priority" field whose options match the
   canonical keys. Because the GitHub provider currently lacks full Projects v2
   coverage, the module orchestrates a small GraphQL helper script via
   `data "external"` for read operations, and a guarded `null_resource` +
   `local-exec` for apply steps. Drift appears clearly in `tofu plan`;
   `tofu apply` performs upserts for missing options.

Both modules execute in the standard OpenTofu runner and respect the apply
workflow already defined in the design: nightly plans surface drift; a manual
`workflow_dispatch` runs `tofu apply` after review.

### 2.4 Sync workflow between labels and Projects

Declarative creation alone does not ensure ongoing consistency—manual edits can
reintroduce skew. A reusable workflow hosted within
`platform-standards/.github/workflows/priority-sync.yml` provides bidirectional
synchronization:

- Triggered on issue label events, Projects v2 item changes, and an optional
  scheduled run.
- When an issue label changes, the workflow updates the matching Projects item,
  creating one if necessary.
- When a Projects field changes, it amends the issue labels accordingly.
- Resolves legacy labels listed in `aliases` by swapping them for the canonical
  key.

Target repositories include a thin caller workflow pinning to a tagged version
of the reusable definition. Authentication uses a repository-scoped Personal
Access Token with `issues:write`, and `projects:write` permissions.

### 2.5 Auditor enforcement and rulesets

The Auditor gains a new "Priority" domain with SARIF rules:

- PR-001 (error): canonical priority labels must exist with the exact names,
  colours, and descriptions from the model.
- PR-002 (warning initially, promotable to error): every open issue must carry
  zero or one canonical priority labels; duplicates, and missing labels are
  flagged.
- PR-003 (error): if a repository or organization board uses Projects v2, the
  "Priority" field must exist with the canonical options.
- PR-004 (warning): legacy labels listed in `aliases` remain only if the sync
  workflow has not yet remediated them.

Findings continue to flow into Code Scanning; existing rulesets can transition
from "evaluate" to "active" to make violations a merge blocker once the
false-positive rate is acceptable. Exemptions use the existing
`standards-exemptions.yaml` mechanism with expiry, and justification.

### 2.6 Role of the concordat CLI

`concordat` still acts as the human entry point:

- `concordat ls` inventories repositories for OpenTofu targeting.
- `concordat enrol` clones the target repository, writes or updates the
  `.concordat` file, and—when `--push` is provided—commits and pushes the change
  via pygit2 (see `concordat/enrol.py`). This preserves the current lightweight
  opt-in flow while keeping repository history intact.
- `concordat estate` bootstraps `platform-standards` repositories from the
  bundled template, persists aliases in `~/.config/concordat/config.yaml`, and
  exposes helpers to list, inspect, and select the active estate. The enrolment
  workflow automatically targets the active estate unless the operator passes
  `--platform-standards-url`.
- `concordat plan` clones the active estate into a temporary workspace, renders
  the OpenTofu variable file from estate metadata, and invokes tofupy's `plan`
  entrypoint, so operators can preview drift without leaving the CLI.
- `concordat apply` reuses the same machinery but calls tofupy's `apply`,
  allowing auditable changes to estates directly from concordat.
- When the `--platform-standards-url` (or `CONCORDAT_PLATFORM_STANDARDS_URL`)
  option is provided, `concordat enrol` also clones the `platform-standards`
  repository, updates `tofu/inventory/repositories.yaml`, runs `tofu fmt`,
  `tflint`, and `tofu validate`, pushes a feature branch, and uses the
  authenticated GitHub token to open a pull request. This satisfies the roadmap
  acceptance criterion that every enrolment produces both the local `.concordat`
  commit and a passing IaC pull request (PR).
- Future extensions may scaffold a pull request that adds the reusable
  `priority-sync` workflow to a repository, but the CLI continues to defer state
  changes to IaC.

### 2.7 Estate execution workflow

The CLI now needs to operate on live estates, not just the template. Two new
commands (`concordat plan` and `concordat apply`) align the workflow with the
state stored in each estate repository.

#### 2.7.1 Configuration invariants

- Estates persist `github_owner` alongside `repo_url`, `branch`, and
  `inventory_path` in the concordat config file. This gives the CLI enough
  context to render `terraform.tfvars` without prompting.
- All inventory records must belong to the same owner. `concordat estate init`
  records the owner and enrolment refuses to add repositories outside the
  namespace.
- When an estate is active, invoking `concordat ls` without namespaces defaults
  to the recorded `github_owner`, offering a zero-argument inventory view.

`concordat estate init` accepts a `--github-owner` flag, so estates backed by
non-GitHub remotes can still record the namespace they manage. When the remote
URL points to GitHub, the CLI infers the owner automatically; otherwise the flag
is required. The active estate must provide `github_owner` before any enrolment
occurs. The `concordat enrol` command queries the active estate, rejects
repositories whose slug resolves to a different owner, and surfaces an explicit
error when the repository or specification does not expose a usable GitHub slug.
This owner guard makes inventory drift visible without blocking template usage,
satisfying the evaluate-mode acceptance criteria.

#### 2.7.2 Workspace management

- Estate repositories are cached under
  `$XDG_CACHE_HOME/concordat/estates/<alias>`. `plan`/`apply` issue a fetch and
  hard reset against this cache before every run.
- Each execution clones the cached workspace into a temporary directory (e.g.
  `/tmp/concordat-plan-XXXX`). This keeps the cache clean and makes it easy to
  tear down state after completion.
- Variable files are generated on the fly in the execution directory. At a
  minimum they set `github_owner`. Sensitive values such as `github_token`
  continue to come from the environment unless the user explicitly requests a
  persisted override.

#### 2.7.3 tofupy integration

- Instead of shelling out directly to the `tofu` binary, the CLI reuses tofupy,
  which provides a Python API mirroring OpenTofu's UX. This keeps error handling
  and output capture in-process.
- `concordat plan` resolves the active estate, prepares the workspace and tfvars
  file, ensures `GITHUB_TOKEN` is exported, then calls tofupy's plan API. The
  CLI streams stdout/stderr and returns a non-zero exit code if the plan fails.
- `concordat apply` performs the identical setup but calls the apply API. It
  passes through approval prompts or accepts `--auto-approve` if the user needs
  unattended applies.
- Both commands emit the execution directory path (helpful for debugging) and
  remove it afterward unless `--keep-workdir` is provided.

To bring repositories under OpenTofu management automatically, `concordat enrol`
will also prepare a pull request against the `platform-standards` repository.
The PR-based approach keeps IaC reviewable and auditable:

1. Clone `platform-standards`, create a feature branch, and edit the repository
   inventory (for example, the map that feeds `for_each` in the root OpenTofu
   module) to include the newly enrolled repository.
1. Run the required quality gates locally (`tofu fmt -check`, `tflint`,
   `tofu validate`, module tests) so reviewers see a passing plan.
1. Commit the HashiCorp Configuration Language (HCL) change, push the branch,
   and open a pull request that links to the `.concordat` commit in the target
   repository.

Only after that PR merges—and the next `tofu plan/apply` cycle runs—will the
repository be considered “in scope” for OpenTofu. Until then, the `.concordat`
file simply signals intent, mirroring the current behaviour of
`concordat/enrol.py`.

The repository inventory lives at
`platform-standards/tofu/inventory/ repositories.yaml`. Each entry contains the
GitHub `owner/name` slug. The inventory drives the `for_each` meta-arguments in
the root OpenTofu modules, which lets the CLI add new repositories without
touching module logic.

### 2.7.4 CLI implementation notes

The delivered CLI follows the workflow above:

- Active estates are refreshed into `$XDG_CACHE_HOME/concordat/estates/<alias>`
  and copied into a per-run temporary directory. The CLI prints the workspace
  path at the start of every execution and removes it afterward unless
  `--keep-workdir` is passed for debugging.
- `terraform.tfvars` is synthesized with the estate's `github_owner` before
  invoking OpenTofu. Commands refuse to run without `GITHUB_TOKEN`, so the
  GitHub provider can load schemas without interactive prompts.
- OpenTofu execution reuses `tofupy.Tufu`, which resolves the `tofu` binary,
  runs `init -input=false`, then relays stdout/stderr from `plan` or `apply`
  while propagating the underlying exit code.
- `concordat apply` requires an explicit `--auto-approve` flag. The CLI adds the
  corresponding `-auto-approve` switch, so unattended applies remain deliberate.

Unit tests cover the estate cache and CLI wiring, and new pytest-bdd scenarios
exercise `plan`, `plan --keep-workdir`, and `apply --auto-approve` end to end
using a fake `tofu` shim. This ensures workspace hygiene and option handling
remain stable as the estate evolves.

### 2.7 Rollout strategy

The rollout mirrors other Concordat standards:

1. Audit phase — introduce drift detection via OpenTofu plans, and Auditor
   warnings only. Publish a priority scorecard.
1. Evaluate phase — apply canonical labels and project fields using the modules;
   encourage repositories to adopt the sync workflow via `multi-gitter` PRs.
1. Active enforcement — promote the Auditor rules to `error` severity and
   activate the ruleset gate.
1. Sustain — add Service Level Objective annotations, dashboards, and optional
   auto-remediation for missing labels.

Edge cases such as archived repositories, mirrors, or opt-out manifests use the
existing exemption model. Repositories without issues bypass label checks
automatically.

### 2.8 Remote tfstate persistence via Scaleway Object Storage

OpenTofu state currently lives on each operator's workstation, which blocks
collaboration and risks corrupted local filesystems. Estates must converge on a
remote backend so every `plan`/`apply` shares the same history, enforces
locking, and unlocks CI execution. Concordat now treats three S3-compatible
providers as first-class backends: Amazon Web Services (AWS) S3, DigitalOcean
Spaces, and Scaleway Object Storage. The OpenTofu S3 backend can manage AWS and
DigitalOcean state without DynamoDB because Terraform/OpenTofu ≥ 1.10 support
native `.tflock` locks when `use_lockfile = true`. Scaleway explicitly documents
that its Object Storage does not implement Terraform locking, so Concordat
serialises applies there (single-writer discipline plus warnings). Credentials
ride in the environment, as with `GITHUB_TOKEN`, and never land in Git history.

#### 2.8.1 Backend specification

The root stack gains an explicit backend declaration in
`platform-standards/tofu/backend.tf`:

```hcl
terraform {
  required_version = ">= 1.10.0"
  backend "s3" {}
}
```

`concordat estate persist` materialises the user-supplied settings into a
checked-in `.tfbackend` file (for example,
`platform-standards/tofu/backend/<provider>.tfbackend`). Concordat renders the
file differently per provider so the semantics stay accurate:

*AWS S3*

```hcl
bucket     = "df12-tfstate"
key        = "estates/<github_owner>/<branch>/terraform.tfstate"
region     = "us-east-1"
use_lockfile = true
```

*DigitalOcean Spaces*

```hcl
bucket                      = "df12-tfstate"
key                         = "estates/<github_owner>/<branch>/terraform.tfstate"
region                      = "nyc3"
endpoints                   = { s3 = "https://nyc3.digitaloceanspaces.com" }
use_path_style              = true
skip_region_validation      = true
skip_requesting_account_id  = true
skip_credentials_validation = true
use_lockfile                = true
```

*Scaleway Object Storage*

```hcl
bucket                      = "df12-tfstate"
key                         = "estates/<github_owner>/<branch>/terraform.tfstate"
region                      = "fr-par"
endpoints                   = { s3 = "https://s3.fr-par.scw.cloud" }
use_path_style              = true
skip_region_validation      = true
skip_requesting_account_id  = true
skip_credentials_validation = true
```

Scaleway variants omit `use_lockfile` entirely because Terraform cannot rely on
locking there today. The backend file is pure configuration regardless of
provider; no credentials are recorded. Operators export Amazon Web Services
(AWS) access keys before invoking Concordat:

```bash
export AWS_ACCESS_KEY_ID=SCWXXXXXXXXXXXXXXXXX
export AWS_SECRET_ACCESS_KEY=xxxxxxxxxxxxxxxxxxxxxxxxxxxx
# Optional when using temporary keys
export AWS_SESSION_TOKEN=...
```

The CLI also supports the Scaleway-specific aliases
`SCW_ACCESS_KEY`/`SCW_SECRET_KEY` and maps them onto the AWS variables before
launching OpenTofu. DigitalOcean Spaces operators can rely on
`SPACES_ACCESS_KEY_ID`/`SPACES_SECRET_ACCESS_KEY`; Concordat applies the same
mapping so every provider reuses the AWS env var contract. The design
deliberately omits `encrypt = true` because Scaleway only offers server-side
encryption with customer-provided keys (SSE-C) and Terraform's backend expects
SSE-S3 headers. At-rest encryption therefore remains a caller concern (for
example, by keeping secrets out of state or using client-side encryption).

Every persistence descriptor ships alongside a YAML manifest
(`platform-standards/tofu/backend/persistence.yaml`) storing a schema version,
bucket, key prefix, region, custom endpoint, and the relative path to the
`.tfbackend` file. This YAML lets the CLI rehydrate defaults when the operator
reruns `estate persist` and provides machine-readable evidence that the estate
is eligible for remote state. The manifest schema is fixed so downstream tools
can parse it reliably:

| Field                 | Type    | Description                                                                                                                                                                                                       |
| --------------------- | ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `schema_version`      | int     | Manifest format version. Bumped when new fields are introduced so older CLIs can refuse unsupported layouts.                                                                                                      |
| `enabled`             | bool    | Whether the estate must use remote state. `false` lets operators opt out temporarily without deleting the manifest.                                                                                               |
| `bucket`              | string  | Remote object-storage bucket that holds Terraform state.                                                                                                                                                          |
| `key_prefix`          | string  | Directory-style prefix (for example, `estates/<owner>/<branch>`). The CLI appends module-specific suffixes.                                                                                                       |
| `region`              | string  | Cloud-provider region/zone identifier (for example, `fr-par`).                                                                                                                                                    |
| `endpoint`            | string  | Fully qualified HTTPS endpoint for the S3-compatible API.                                                                                                                                                         |
| `backend_config_path` | string  | Relative path to the generated `.tfbackend` file that OpenTofu consumes.                                                                                                                                          |
| `notification_topic`  | string? | Optional log-routing or pub/sub topic identifier. When populated, `concordat apply` emits a JSON log line to this target whenever lock acquisition exceeds 60 seconds so alerting pipelines can notify operators. |

The YAML mirrors these fields verbatim, so automation can treat missing optional
keys (such as `notification_topic`) as unset values. Section 2.8.4 details the
alerting and disaster-recovery flows that consume these attributes.

Every backend bucket—AWS, DigitalOcean, or Scaleway—must enable versioning
before the CLI writes any state. The command performs a
`HeadBucket`+`GetBucketVersioning` check via boto3, emits a blocking error if
versioning is disabled, and surfaces a warning (not an error) when Object Lock
is absent. Object Lock (the WORM/immutability feature) hardens retention but is
orthogonal to Terraform's `.tflock` mutexes.

#### 2.8.2 `estate persist` interactive workflow

`concordat estate persist` behaves similarly to `concordat enrol`: it stages a
branch inside the estate repository, writes deterministic artefacts, and opens a
pull request. The workflow is:

- Resolve the target estate (explicit `--alias` or the active record) and fetch
  it into the local cache. Dirty worktrees abort the command to keep diffs
  surgical.
- Load any prior `persistence.yaml` so prompts are pre-filled when operators
  rotate buckets or rename prefixes.
- Prompt for the storage provider (AWS, DigitalOcean, or Scaleway) plus bucket
  name, region slug, S3 endpoint URL, and the desired state key suffix. The CLI
  suggests `estates/<github_owner>/<branch>/terraform.tfstate` and asks whether
  the estate hosts multiple stacks. Answering "yes" tells the CLI to record one
  suffix per stack (for example, `estates/<owner>/<branch>/envs/prod`).
  `concordat estate persist` runs once per stack so each `.tfbackend` captures a
  unique key. The CLI does not infer stack layouts automatically; operators
  follow the documented convention of appending `envs/<stack>` (or another
  deterministic folder) to keep state segregation obvious.
- Validate inputs by checking S3 bucket access (using the mapped AWS
  credentials), ensuring key suffixes do not contain directory traversals, and
  confirming the endpoint uses HTTPS. All validation happens before touching Git
  history.
- Render both `backend.tf` and `backend/<alias>.tfbackend`, plus the YAML
  descriptor, then run `tofu fmt` to keep formatting consistent.
- Create a branch named `estate/persist-<timestamp>`, commit the new files with
  an imperative subject (for example, `Configure Scaleway remote state`), push
  via pygit2, and open a pull request against the estate repository that
  restates the collected parameters and links to the relevant provider's
  versioning/locking docs.
- Leave the branch locally (so operators can amend) and print the PR URL.

The command never stores credentials: it merely verifies that the current
environment can talk to the bucket. Re-running `estate persist` updates the YAML
manifest and regenerates the `.tfbackend`; destructive changes (such as bucket
renames) require an explicit `--force` flag so that operators acknowledge the
state migration impact.

#### 2.8.3 Execution-time behaviour

`concordat plan` and `concordat apply` now inspect the checked-in
`persistence.yaml` while preparing the estate workspace:

- If the file exists and `enabled: true`, the CLI appends
  `-backend-config=<path>` to the `tofu init -input=false` invocation. The path
  is resolved relative to the estate root so ephemeral workspaces can reuse it
  verbatim.
- Missing Amazon Web Services (AWS)/DigitalOcean/Scaleway environment variables
  trigger a descriptive error before `tofu init` runs, preventing OpenTofu's
  opaque credential failures. When the descriptor is absent, both commands
  retain the current local-state default.
- The initialisation log echoes the bucket, key, and region (never secrets) so
  operators have traceability in Continuous Integration (CI) logs.
- Backends remain immutable once initialised; the command-line interface (CLI)
  refuses to mix local and remote state in the same workspace unless the
  operator wipes `.terraform` explicitly. This protects estates from partial
  migrations.

Because the backend lockfile feature landed in Terraform/OpenTofu 1.10 (beta
builds shipped first and 1.10.0 is the minimum stable release) the
command-line interface (CLI) no longer needs DynamoDB when targeting AWS or
DigitalOcean. Those providers honour the conditional writes behind native
`.tflock` objects, so secondary applies surface the standard "state locked"
message with the locking object key. When persistence points at Scaleway, the
CLI omits `use_lockfile`, prints a warning about the missing mutex, and relies
on single-writer discipline to keep state consistent.

#### 2.8.4 Failure handling and observability

- Preflight validation: `estate persist` performs a zero-byte `PutObject`
  followed by a delete in the configured prefix to ensure the access keys own
  write/delete permissions. It rolls back any temporary object on failure and
  surfaces permission errors with actionable guidance.
- Health checks (planned): a future `concordat apply --check-lock` mode will
  attempt to acquire the backend lock using OpenTofu's APIs and report the
  blocking key when contention persists. The current CLI does not yet implement
  this flag; running `tofu state lock -help` only prints usage and cannot detect
  stuck locks, so operators presently depend on the `.tflock` metadata echoed in
  apply logs.
- Alerting hooks: the persistence YAML includes an optional `notification_topic`
  key. When populated, the CLI emits a structured log line whenever lock
  acquisition exceeds 60 seconds, giving downstream log routers enough context
  to alert.
- At-rest encryption guidance: state files often contain credentials and other
  sensitive data. Operators must:
  - Avoid storing secrets in state whenever possible by marking attributes as
    `sensitive = true`, splitting secrets into separate vaults, or replacing
    cleartext values with references. (See Terraform security best practices
    from OWASP and HashiCorp.)
  - Enforce strict bucket/object policies: enable bucket versioning, require
    server-side encryption where available (for example, AWS S3 SSE-S3/KMS), and
    limit access via IAM or Scaleway access policies.
  - Use client-side encryption for buckets that lack supported server-side
    encryption (e.g., Scaleway SSE-C): wrap `tofu state`/`tofu plan` calls with
    tooling that encrypts state files before upload, or leverage external
    envelope-encryption workflows.
  - Periodically audit access logs for the bucket to detect unauthorized reads.
- Disaster recovery: operators can leverage Scaleway's bucket versioning to roll
  back a corrupted state by copying the previous version over the active object.
- Disaster recovery: operators can leverage Scaleway's bucket versioning to roll
  back a corrupted state by copying the previous version over the active object.
  The design doc emphasises that Concordat will not automate rollbacks; it
  simply guarantees that version IDs appear in the CLI output whenever an apply
  updates state.
  - Scaleway: enable Object Lock's compliance mode with retention windows that
    match regulatory needs to reduce tampering risk even without SSE-S3.

This design keeps state durable, auditable, and vendor-neutral while calling out
provider-specific capabilities so operators know where `.tflock` locking is
guaranteed (AWS, DigitalOcean) and where it is not (Scaleway).

## 3. Squash-only merge standard test case

Repository standard RS-002 (squash-only merges) now ships as an executable
OpenTofu stack, so operators can inspect drift with a single `tofu plan`. The
stack lives at `platform-standards/tofu` and decodes
`platform-standards/tofu/inventory/repositories.yaml`, which now includes the
non-production entry `test-case/squash-only-standard`. Each inventory record
retains the historical `name: owner/repo` slug so the CLI can continue to append
new repositories without understanding optional settings.

- `platform-standards/tofu/main.tf` materializes the inventory into a
  `module "repository"` for every slug, enforcing that the owner component
  matches the `github_owner` variable (defaulting to `test-case`). The populated
  module parameters surface consistent defaults for topics, visibility, and
  branch deletion so that even minimalist records render a valid repository
  plan.

- `platform-standards/tofu/modules/repository` now contains lifecycle
  preconditions that require `allow_squash_merge = true` and both
  `allow_merge_commit` and `allow_rebase_merge` to remain `false`. This aligns
  the IaC definition with RS-002 and prevents drift-inducing overrides.

- Policy parity arrives via `platform-standards/tofu/policies/repository.rego`,
  which denies plans that disable squash merges or re-enable merge/rebase paths.
  Example payloads under `platform-standards/tofu/policies/examples` and unit
  tests in `repository_test.rego` exercise the happy and unhappy paths.

- Quality gates cover the full testing pyramid: `tofu test` now includes an
  `apply` run with a mocked provider so merge outputs stay assertable, Terratest
  fixtures fail when disallowed strategies are re-enabled, and `conftest test`
  validates Rego rules before any plan reaches apply.

- Operators can run the command below to preview the changes required to enforce
  the standard. Exit code `2` flags drift, while exit code `0` confirms the
  inventory already conforms:

  ```shell
  GITHUB_TOKEN=placeholder tofu -chdir=platform-standards/tofu \
    plan -var github_owner=test-case -detailed-exitcode
  ```

### 1.3. Technology stack rationale

The selection of each tool in the technology stack is deliberate, favouring a
declarative, GitOps-centric model for organizational governance. This approach
moves away from imperative scripting, and manual intervention. The stack is
composed of best-in-class, open-source solutions for each specific domain,
ensuring the framework is powerful, extensible, and avoids vendor lock-in.

The management of a large GitHub estate involves handling distinct types of
state: API-level settings (e.g., repository configuration), structured file
content (e.g., YAML workflows), and unstructured prose (e.g., documentation). No
single tool excels at managing all three, necessitating a composite architecture
where each component is specialized for its task.

For API-driven resources, OpenTofu is the logical choice. Its declarative
nature, and plan/apply cycle, along with the state file, provide the
capabilities needed to detect drift, then remediate it when managing GitHub
settings as code.1 As a fork of Terraform, it remains fully compatible with the
mature, comprehensive GitHub provider. That reliability makes it a powerful,
low-risk choice for this domain.2

For validating structured configuration files, a dedicated policy engine is
superior to ad-hoc scripts. The Open Policy Agent (OPA), and its command-line
utility, Conftest, represent the industry standard. OPA's query language, Rego,
is purpose-built for asserting policies over structured data like YAML or JSON,
making it far more robust and maintainable than alternatives.4

For ensuring the quality of unstructured prose, a specialized linguistic tool is
required. Vale is a purpose-built prose linter capable of codifying an entire
style guide into a set of machine-enforceable rules, a task for which
general-purpose text-matching tools are ill-suited.6

Finally, GitHub Actions serves as the native automation engine for orchestration
as well as remediation. For the specific task of creating pull requests across
many repositories simultaneously, a specialized tool like `multi-gitter` is more
ergonomic, and efficient than a general-purpose configuration management tool
such as Ansible.8

This curated set of specialized components is a key architectural strength and
yields a system that is more maintainable and more powerful than any monolithic
alternative.

#### Table 1: Technology stack and rationale

| **Tool**                                      | **Primary Role in Framework**                                                           | **Justification**                                                                                                                                                         | **Rejected Alternative(s) & Rationale**                                                                                                                           |
| --------------------------------------------- | --------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **OpenTofu**                                  | Declarative management of GitHub API resources (repositories, teams, rulesets).         | Provides a declarative, stateful approach with drift detection (`plan`), and remediation (`apply`). Fully compatible with the mature Terraform GitHub provider.[^9][^10]  | **Ansible:** Imperative, not stateful. Less ergonomic for detecting drift in API-managed resources compared to a dedicated IaC tool.                              |
| **OPA/Conftest**                              | Policy-as-code engine for validating structured configuration files (e.g., YAML, JSON). | Provides a powerful, declarative language (Rego) specifically designed for querying structured data. Enables testable, version-controlled policies.[^4][^11]              | **Custom Scripts (Python/Shell):** Brittle, harder to maintain, and lacks the expressive power of Rego for complex policy evaluation.                             |
| **Vale**                                      | Prose linter for enforcing documentation, and style guide standards.                    | Codifies linguistic and stylistic rules far more effectively than simple regular expressions. Supports custom, shareable style packs.[^6][^12]                            | **Ad-hoc Regex Scripts:** Inadequate for handling the complexities of natural language; difficult to maintain, and scale.                                         |
| `multi-gitter`                                | Scaled remediation via mass pull request generation.                                    | A specialized tool purpose-built for the task of multi-repository changes. More ergonomic and efficient than general-purpose tools.8                                      | **Custom Scripts using **`gh`** CLI:** Requires significant boilerplate code to handle cloning, branching, committing, and creating PRs across many repositories. |
| **GitHub Actions**                            | Primary automation, and orchestration engine.                                           | Native to the platform, providing seamless integration for CI/CD, scheduled tasks, and event-driven automation.[^13][^14]                                                 | **External CI/CD Systems (e.g., Jenkins):** Adds operational overhead, and complexity compared to the tightly integrated native solution.                         |
| **Open Source Security Foundation Scorecard** | Security posture assessment.                                                            | Provides a standardized, automated baseline for security best practices. Integrates easily into CI workflows, and is maintained by the Open Source Security Foundation.15 | **Manual Security Audits:** Not scalable, inconsistent, and cannot be integrated into an automated enforcement gate.                                              |

## 2. Foundational components

This section provides detailed specifications for the static, foundational
elements of the framework: the central standards repository that holds the
canonical definitions, and the per-repository metadata file that provides the
context for applying those definitions.

### 2.1. The `platform-standards` repository: a canonical source of truth

The `org/platform-standards` repository is the definitive source of truth for
all standards, policies, and configurations. Its structure must be strictly
maintained to ensure the correct functioning of the Auditor, and OpenTofu
pipelines.

The mandated directory structure is as follows:

- `canon/`: This directory contains canonical file templates and configuration
  fragments. These files represent the "gold standard" versions that the Auditor
  will check for presence and integrity in target repositories. This includes:

- `.github/workflows/`: Reusable GitHub Actions workflows (e.g., `ci.yml`,
  `release.yml`).

- `lint/`: Standardized linter configurations (e.g., `python/ruff.toml`,
  `js/eslint.config.js`).

- `docs/`: Canonical documentation templates (`AGENTS.md`), Vale configuration
  (`.vale.ini`), and custom Vale style packs (`Styles/`).

- `make/`: Reusable Makefile fragments (`includes.mk`).

- `policies/`: This directory contains all OPA/Rego policies used by Conftest
  for validation. Organizing policies by domain (e.g., `workflows/`, `repo/`,
  `security/`) allows for modularity, enabling policies to be tested, and
  versioned independently.4

- `tofu/`: This directory contains the master OpenTofu configuration for
  managing the GitHub estate. It is structured with modules to promote reuse and
  maintainability (e.g., `modules/repo-defaults/`, `modules/rulesets/`).18

- `tools/auditor/`: This directory contains the source code for the custom
  Auditor GitHub Action itself. This includes the main Python application, its
  dependencies (e.g., `requirements.txt`), and the GitHub Action metadata file
  (`action.yml`).

- `manifest.yaml`: The machine-readable index that enumerates every published
  canonical artefact (path, SHA-256 checksum, and descriptive metadata). The
  Auditor and `concordat` tooling resolve canonical resources exclusively via
  this manifest located at `platform-standards/canon/manifest.yaml`, ensuring
  deterministic pinning even when the repository grows.

The repository also provides the `scripts/canon_workflows.py` driver, which
invokes [nektos/act](https://github.com/nektos/act) to execute workflow dispatch
events against the canonical workflows. This enables local smoke tests and is
itself covered by `pytest` + `cmd_mox` fixtures so that CI can verify the
expected `act` invocation without contacting GitHub Actions.

### 2.2. The `.concordat` manifest: a formal schema definition

The `.concordat` file, located at the root of each target repository, is the
primary mechanism for enabling conditional logic within the framework. Its
presence—and in particular the `enrolled: true` flag—is the first check the
Auditor and the OpenTofu pipeline perform. This manifest is more than just
metadata; it is the formal "contract" between a repository and the platform. It
allows the central platform team to apply nuanced, context-aware policies
without hard-coding repository-specific exceptions, which is essential for
maintaining scalability.

A one-size-fits-all policy is inherently brittle; a Python library has different
standardization needs from a Go microservice or an OpenTofu infrastructure
repository. While fallbacks like repository topics or file detection can provide
hints, they are not reliable enough for a strict enforcement system. A
declarative manifest file shifts the responsibility of declaration to the
repository owners, who possess the most accurate context. By stating
`language.primary: python`, the repository owner explicitly opts into the suite
of Python-related standards, such as the requirement for a `ruff.toml` file.

This design decouples the specific context of a repository from the generic
logic of the standards framework. The central Auditor's logic remains generic
and scalable; it does not need to know about "repo-A" or "team-B". It simply
reads the `.concordat` manifest, and applies policies conditionally based on the
declared attributes (e.g., `if input.manifest.language.primary == "python"`).
This decoupling is a critical design pattern for achieving a maintainable and
scalable governance system.

The formal schema for this file is defined below.

#### Table 2: Schema for `.concordat`

| **Field Path**              | **Data Type** | **Requirement**                      | **Description**                                                                                                                                                                                  |
| --------------------------- | ------------- | ------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `enrolled`                  | Boolean       | Required                             | Must be set to `true` to signal that the repository is under Concordat/OpenTofu management.                                                                                                      |
| `language.primary`          | String        | Required                             | The primary programming language of the repository. Must be a lowercase string (e.g., `python`, `go`, `typescript`). This value drives the selection of language-specific linting, and CI rules. |
| `language.others`           | Array         | Optional                             | A list of other significant languages present in the repository (e.g., `shell`, `make`).                                                                                                         |
| `infrastructure.opentofu`   | Boolean       | Optional                             | Set to `true` if the repository contains OpenTofu/Terraform code. This enables checks for `Makefile` targets like `tf-plan`. Defaults to `false`.                                                |
| `infrastructure.kubernetes` | Boolean       | Optional                             | Set to `true` if the repository contains Kubernetes manifests. This enables Kubernetes-specific validation rules. Defaults to `false`.                                                           |
| `docs.style`                | String        | Optional                             | The name of the Vale style to apply. Must correspond to a directory name in `platform-standards/canon/docs/Styles/`. Example: `your-house`.                                                      |
| `libraries`                 | Array[Object] | Optional                             | A list of critical internal libraries consumed by this repository, used for guide parity checks.                                                                                                 |
| `libraries.name`            | String        | Required (if `libraries` is present) | The name of the consumed library repository (e.g., `acme-lib`).                                                                                                                                  |
| `libraries.version_tag`     | String        | Required (if `libraries` is present) | The Git tag of the library version being used (e.g., `v2.4.1`). The Auditor uses this to fetch the correct version of the library's user guide for comparison.                                   |
| `ci.needs_release_workflow` | Boolean       | Optional                             | Set to `true` if the repository should be configured with the canonical release workflow. Defaults to `false`.                                                                                   |

### 2.3 Comment-preserving remediation provider

Concordat’s enforcement loop now includes a purpose-built OpenTofu provider
(`concordat/file`) that evaluates Rego policies against repository manifests and
produces comment-preserving patches instead of rewriting files directly. This
keeps file standards declarative, ensures audits remain cheap, and routes all
enforcement through reviewable pull requests.

The provider exposes:

- `concordat_file_opa_plan_toml` (data source) — loads a TOML file (for example,
  `Cargo.toml`), runs the pinned Rego planner rule from
  `platform-standards/canon/policies/...`, and returns an RFC 6902 patch list,
  summary text, and any findings. The provider converts TOML to canonical JSON
  for policy input but preserves the original abstract syntax tree (AST) so
  comments survive.
- `concordat_file_toml_remediation_pr` (resource) — applies the planned patch
  set using the AST, commits the change to a feature branch, and opens a PR via
  the GitHub API. The resource never writes to the default branch and requires a
  clean worktree, mirroring Concordat’s PR-first principle.
- (Optional) `concordat_file_toml_preview` (data source) — renders the pretty
  diff that will appear in the remediation PR, allowing Auditor workflows to
  embed the exact change summary into SARIF diagnostics.

Provider configuration pins the exact `platform-standards` ref and policy
directory, so nightly plans remain deterministic (`platform_standards_ref`,
`policy_dir`). Planner rules are declared in Rego (for example,
`data.canon.rust.lints.plan_toml`) alongside the companion deny rules and
include helper functions for JSON Pointer ↔ TOML path translation. Releasing
this provider as a shared component avoids bespoke scripts and gives the estate
a consistent interface for policy-driven remediation.

### 2.3. The organization-level `.github` repository

To provide sensible defaults for community health files across the entire
organization, a public repository named `.github` must be created at the
organization level. This is a native GitHub feature that automatically provides
default files for repositories that do not contain their own.

This repository will contain the organization's standard versions of:

- `CODE_OF_CONDUCT.md`
- `CONTRIBUTING.md`
- `SECURITY.md`

Individual repositories can override these defaults by including their own
versions of these files. The Auditor checks whether those files exist in the
local repository or originate from the organizational default.

## 3. The auditor: a centralized evaluation engine

The Auditor is the active component of the framework, responsible for performing
all compliance checks. It is designed as a centralized, configurable engine that
runs within the GitHub Actions environment.

### 3.1. Functional specification, and audit domains

The Auditor's responsibilities are partitioned into logical domains to structure
its checks and reporting. Each domain corresponds to a distinct area of
engineering standards.

The primary audit domains are:

1. **Repository Settings:** Validates settings that are primarily managed by
   OpenTofu (e.g., default branch name, merge strategies) by querying the GitHub
   API directly. This provides a secondary, independent verification of the
   IaC-managed state, acting as a cross-check against manual overrides or IaC
   failures.
1. **CI/CD Integrity:** Ensures that repository workflows correctly invoke the
   canonical reusable workflows from `platform-standards`, and do not use
   disallowed third-party GitHub Actions. This is implemented via OPA/Conftest
   policies that parse the YAML workflow files to verify their structure and
   content.20
1. **File and Content Presence:** Verifies the existence and, where necessary,
   the content integrity of canonical files defined in
   `platform-standards/canon/`. Content integrity checks can range from a simple
   checksum match for files that must be identical, to a more complex structural
   validation via OPA for configuration files.
1. **Prose, and Documentation Quality:** Executes the Vale prose linter against
   all Markdown files within the repository to enforce the organization's house
   style guide, checking for issues related to grammar, tone, and terminology.6
1. **Security Posture:** Integrates, and executes the Open Source Security
   Foundation Scorecard tool. The numeric score and specific findings from
   Scorecard are incorporated into the Auditor's overall report, providing a
   consistent, organization-wide security baseline.15

The following table serves as the master list of requirements for the Auditor.
It defines the scope of work for implementation, and provides an itemised
breakdown of what constitutes "compliance" within the framework.

#### Table 3: Auditor check catalog

| **Check ID** | **Description**                                                                                                                      | **Audit Domain**                | **Implementation Tool**                   | **Default Severity** | **Implementation Phase** |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------- | ----------------------------------------- | -------------------- | ------------------------ |
| RS-001       | Default branch is named `main`.                                                                                                      | Repository Settings             | Python/GitHub API                         | error                | 1                        |
| RS-002       | Squash merging is enabled; merge commits and rebase merging are disabled.                                                            | Repository Settings             | Python/GitHub API                         | error                | 1                        |
| RS-003       | "Delete branch on merge" is enabled.                                                                                                 | Repository Settings             | Python/GitHub API                         | error                | 1                        |
| BP-001       | Default branch protection enforces admin parity, signed commits, reviews, and strict status checks (including the Auditor).          | Branch Governance               | Python/GitHub API                         | error                | 1                        |
| PM-001       | Repository permissions route through at least one team with maintain/admin scope and expose no outside collaborators with admin.     | Repository Access Controls      | Python/GitHub API                         | error                | 1                        |
| LB-001       | Canonical priority labels (`priority/p0`–`priority/p3`) exist with the correct colour and description metadata.                      | Label Governance                | Python/GitHub API                         | warning              | 1                        |
| CI-001       | The `.github/workflows/ci.yml` file must call the canonical reusable CI workflow.                                                    | CI/CD Integrity                 | OPA/Conftest                              | error                | 1                        |
| CI-002       | The `.github/workflows/release.yml` file must call the canonical reusable release workflow (if `ci.needs_release_workflow` is true). | CI/CD Integrity                 | OPA/Conftest                              | error                | 2                        |
| CI-003       | Workflows must not use disallowed third-party GitHub Actions.                                                                        | CI/CD Integrity                 | OPA/Conftest                              | error                | 2                        |
| FP-001       | A `.editorconfig` file must exist and match the canonical version.                                                                   | File and Content Presence       | Python/Checksum                           | error                | 1                        |
| FP-002       | An `AGENTS.md` file must exist and contain required sections.                                                                        | File and Content Presence       | Python/Content Check                      | error                | 1                        |
| FP-003       | A `Makefile` must exist and contain canonical targets (`lint`, `test`, `build`).                                                     | File, and Content Presence      | Python/Content Check                      | error                | 2                        |
| FP-004       | For Python projects, a `ruff.toml` file must exist.                                                                                  | File, and Content Presence      | OPA/Conftest                              | error                | 1                        |
| PD-001       | All Markdown files must pass Vale linting against the house style guide.                                                             | Prose and Documentation Quality | Vale                                      | warning              | 2                        |
| SP-001       | The Open Source Security Foundation Scorecard must achieve a minimum score of 7.0.                                                   | Security Posture                | Open Source Security Foundation Scorecard | warning              | 1                        |
| LG-001       | The `docs/library-users-guide.md` file must match the canonical version from the consumed library tag.                               | File and Content Presence       | Python/Content Check                      | error                | 4                        |

### 3.2. Implementation design and execution model

The Auditor will be implemented as a composite GitHub Action, primarily written
in Python 3. This approach provides the necessary flexibility to orchestrate
calls to external command-line tools like Conftest, and Vale, while also
allowing for direct interaction with the GitHub API via a robust client library.

The execution flow of the Auditor action is as follows:

1. **Trigger:** The action is triggered by a GitHub Actions workflow event, such
   as `pull_request` or `schedule`.

1. **Checkout:** The workflow checks out the code of the target repository. It
   also checks out a specific, pinned version of the `platform-standards`
   repository into a separate directory to ensure that the audit uses a stable
   version of policies, and canonical files.

1. **Metadata parsing:** The Python script begins by locating, reading, and
   parsing the target repository's `.concordat` file. If the file is missing,
   invalid, or does not contain `enrolled: true`, the audit fails immediately.

1. **Parallel check execution:** The script orchestrates the execution of the
   various audit domain checks, running them in parallel where feasible to
   minimize execution time:

   - A subprocess is spawned to execute `conftest test`, pointing it to the
     relevant configuration files in the target repository, and the policy
     directory within the checked-out `platform-standards` repository.
   - A subprocess is spawned to execute `vale`, configured to use the
     `.vale.ini` from `platform-standards`, and targeting all Markdown files in
     the target repository.
   - A Python GitHub API client fetches repository and branch protection
     settings directly from the GitHub API.
   - A subprocess is spawned to execute the `scorecard` command-line interface
     against the target repository.

1. **Result aggregation:** The main Python script collects and normalizes the
   output from all checker subprocesses.

1. **SARIF generation:** The aggregated results are transformed into a single,
   valid SARIF 2.1.0 file. Each finding is represented as a `result` object
   within the SARIF log.

1. **SARIF upload:** The final step in the job invokes the official
   `github/codeql-action/upload-sarif` action, passing it the path to the
   generated SARIF file.

#### 3.2.1 Composite GitHub Action packaging

The reference implementation now ships inside
`.github/actions/auditor/action.yml`. The composite action handles the entire
bootstrap process:

- It installs the `concordat` Python package from the root of this repository,
  ensuring the CLI and dependencies match the workflow revision.
- Inputs expose the repository slug, output path for the SARIF artefact,
  optional overrides for the canonical `priority-model.yaml`, and an optional
  JSON snapshot. The snapshot flag exists purely for local testing with `act`,
  so maintainers can run the workflow without contacting the GitHub API.
- A single step runs `python -m concordat.auditor`, writing the SARIF log to
  `artifacts/concordat-auditor.sarif` by default and surfacing the path via
  action outputs. Downstream steps upload the artefact for inspection and, when
  not explicitly disabled, call `github/codeql-action/upload-sarif@v3` so the
  Code Scanning dashboard ingests the findings.

The scheduled workflow `.github/workflows/auditor.yml` invokes this composite
action nightly (`0 5 * * *`) with permissions limited to `contents: read` and
`security-events: write`. A manual `workflow_dispatch` input set allows teams to
supply a fixture snapshot and skip the upload (`upload_sarif=false`), which
keeps local smoke tests hermetic.

### 3.3. Reporting mechanism: SARIF integration with GitHub code scanning

The Auditor **must** output all its findings in the Static Analysis Results
Interchange Format (SARIF). This is a critical strategic decision that elevates
the Auditor from a simple pass/fail CI check into a rich, integrated developer
experience tool, and it is the technical lynchpin of the framework's enforcement
mechanism.23

A simple log output from a CI job is easily missed, and cannot be used as a
granular gate for branch protection. The GitHub Code Scanning feature, however,
provides a much richer integration. It is designed to ingest security and
quality findings via SARIF files. By adopting SARIF as the single, unified
output format, all disparate findings—from OPA policy violations, Vale prose
suggestions, Scorecard security risks, and custom Python checks—can be
consolidated into a single, machine-readable artefact.

When this SARIF file is uploaded, GitHub treats the findings as native Code
Scanning alerts. This has two profound consequences:

1. **Enhanced Developer Experience:** Violations appear directly within the
   GitHub user interface on the "Security" tab. Crucially, they also appear as
   annotations on the pull request's "Files changed" view, placing the feedback
   directly adjacent to the offending code or configuration. This is a far
   superior feedback mechanism to forcing developers to parse CI logs.
1. **Robust Enforcement:** The status of the Code Scanning analysis itself
   becomes a status check that can be required for merging. A GitHub Ruleset can
   be configured to require that the "Code scanning results" check passes. This
   effectively transforms the entire suite of Auditor checks into a mandatory,
   non-bypassable merge gate, thus fulfilling the core "enforcement" requirement
   of the framework.

SARIF is therefore not merely a reporting format; it is the key technology that
connects the Auditor's evaluation logic to GitHub's native user interface and
enforcement machinery, making the entire system cohesive, consistent, and
effective.

## 4. Declarative estate management with OpenTofu

This section specifies how OpenTofu will be used to manage the GitHub estate's
configuration declaratively. This ensures that all repositories, and teams
adhere to a baseline configuration, provides an auditable history of changes,
and enables automated detection of configuration drift.

### 4.1. Managing repository configuration and settings

The `github_repository` resource, provided by the OpenTofu GitHub provider, will
be the primary mechanism for standardizing settings across all managed
repositories.25 The OpenTofu configuration resides in the
`platform-standards/tofu/` directory and defines a module responsible for
repository creation and management.

Key settings to be managed declaratively include:

- `visibility`: To enforce whether repositories are `public`, `internal`, or
  `private`.
- `has_issues`, `has_wiki`, `has_projects`: To standardize the feature set
  available on repositories.
- `delete_branch_on_merge`: To enforce repository hygiene.
- Merge strategies: `allow_squash_merge`, `allow_merge_commit`,
  `allow_rebase_merge` will be set to enforce a consistent merge strategy across
  the organization.

A `for_each` meta-argument in the root OpenTofu configuration will iterate over
a map of managed repositories, applying this common module to each one to ensure
consistent application of these default settings.

### 4.2. Managing teams, and permissions

To ensure that access control is managed as code and is subject to audit as well
as periodic review, OpenTofu will be used to manage team membership and
repository permissions. The following resources will be used:

- `github_team`: To create, and manage the existence of teams within the
  organization.
- `github_team_membership`: To manage the members of each team.
- `github_team_repository`: To associate teams with repositories and grant
  specific permission levels (e.g., `read`, `triage`, `write`, `maintain`,
  `admin`).

This approach provides a transparent, and auditable record of who has access to
which resources, and why.

### 4.3. Nightly drift detection, and remediation workflows

A critical function of the IaC pipeline is the continuous detection and
correction of drift. A naive approach of automatically running `tofu apply` on a
schedule is unacceptably risky, as a bug in the configuration, an unexpected
provider change, or operator error could lead to a destructive plan (e.g.,
deleting a repository) being applied without human oversight.

Therefore, a safer two-step process that separates detection from remediation is
mandated:

1. **Nightly Drift Detection:** A GitHub Actions workflow will run on a nightly
   schedule. Its sole purpose is to detect drift. It will execute
   `tofu plan -detailed-exitcode`. This command is a safe, read-only operation.
   It exits with code `0` if there is no drift, `1` for an error, and `2` if
   drift is detected. If the exit code is `2`, the workflow will fail,
   immediately alerting the platform team. The full plan output will be uploaded
   as a workflow artefact for detailed inspection.
1. **Manual Remediation Trigger:** A separate workflow, triggered manually via
   `workflow_dispatch`, will be available to authorized operators. After
   reviewing the plan output from the detection workflow, and confirming that
   the proposed changes are correct and intended, an operator can trigger this
   workflow to execute `tofu apply -auto-approve`, which will reconcile the
   state of the GitHub estate with the declarative configuration.

This two-step process provides the benefits of fully automated drift detection
while retaining the critical safety feature of a human review gate before making
potentially destructive changes, balancing automation with operational safety.

## 5. Policy enforcement, and compliance gates

This section details the specific mechanisms for policy enforcement, from the
validation of file content to the implementation of the final, non-bypassable
merge gate.

### 5.1. Content validation with OPA/Conftest

The Auditor will invoke `conftest test` against relevant structured
configuration files (YAML, JSON, etc.) found in the target repository. The
policies used for this validation will be sourced from the checked-out
`platform-standards/policies/` directory.

Example policies that must be implemented include:

- A policy that parses `.github/workflows/ci.yml`, and asserts that it contains
  a `jobs.*.uses` key pointing to a versioned, canonical reusable workflow
  (e.g., `org/platform-standards/.github/workflows/ci.yml@v1`).
- A policy that validates the structure of a `renovate.json` file to ensure that
  only approved package managers, and update schedules are configured.
- A policy, which runs conditionally based on the `language.primary` field in
  `.concordat` being `python`, that verifies a `ruff.toml` file exists and
  contains a required set of linting rules.

To facilitate integration with the overall reporting mechanism, the `conftest`
command will be configured to output its results in SARIF format using the
`--output sarif` flag.17

#### 5.1.1 From findings to patch plans

Audit alone is insufficient for fast remediation, so the same Rego packages
include a **planner** rule that emits the JSON-Patch operations needed to bring
the file into compliance (for example, the `plan_toml` rule in
`canon/rust/lints_policy.rego`). The OpenTofu `concordat/file` provider reads
those planner rules, evaluates them against the checked-out repository files,
and makes the resulting plan available to both humans and automation:

- Nightly `tofu plan` runs call the data source and gate on `patch_count == 0`,
  surfacing drift without mutating anything.
- Operator-triggered `tofu apply` runs depend on
  `concordat_file_toml_remediation_pr`, which reuses the exact patch payload,
  applies it via the comment-preserving TOML engine, and raises a PR for review.

This approach keeps the Auditor and the remediation provider aligned: they share
policy definitions, rely on the same canonical checkout of `platform-standards`,
and preserve Git history via PRs rather than silent commits.

### 5.2. Prose, and documentation linting with Vale

To enforce consistency in all written materials, the Auditor will invoke the
`vale` command-line tool. The tool will be configured to target all Markdown
files (`--ext=.md`) within the repository. The configuration file (`.vale.ini`)
and any custom style packs (`Styles/YourHouse/`) will be sourced from the
`platform-standards/canon/docs/` directory. This ensures that all documentation,
from the main `README.md` to developer guides, and the `AGENTS.md` file, adheres
to the defined house style guide for tone, grammar, and terminology.12

### 5.3. Enforcement via GitHub rulesets and required status checks

The ultimate enforcement point of the entire framework is the GitHub Ruleset.
Rulesets provide the modern mechanism for protecting branches and tags in GitHub
and offer superior capabilities to legacy branch protection rules. Unlike those
legacy rules, rulesets are composable, meaning multiple rulesets from different
sources (e.g., organization-level, repository-level) can apply to the same
branch simultaneously, with the most restrictive combination of rules being
enforced. This layering capability is vital for a large organization.
Furthermore, rulesets are visible to any user with read access, providing
transparency, and they can be managed declaratively via the API and,
consequently, via OpenTofu.27

The enforcement loop will be closed as follows:

1. An OpenTofu module, located at `tofu/modules/rulesets/`, will define a
   standard ruleset.
1. This ruleset will be applied via OpenTofu to the default branch of all
   managed repositories. The `github_repository_ruleset` resource is used for
   this purpose.29
1. The key rule within this ruleset will be `required_status_checks`. This rule
   will be configured to require the status check generated by the Auditor's
   SARIF upload to have a successful conclusion. The `context` of this check
   typically follows the pattern `Code scanning results / <tool-name>`.
1. Because the Auditor's SARIF report includes all findings, a single
   `error`-level finding from any of its checks (OPA, Vale, Scorecard, etc.)
   will cause the Code Scanning result to be non-successful.
1. This configuration makes the entire suite of Auditor checks a mandatory,
   non-optional gate that must pass before any pull request can be merged.

### 5.4. Standardization via reusable GitHub workflows

To eliminate redundancy and enforce consistent CI/CD practices, the framework
will heavily leverage reusable GitHub Actions workflows. The canonical,
authoritative versions of these workflows will reside in the
`platform-standards/canon/.github/workflows/` directory.13

These workflows will be designed for flexibility by using the
`on.workflow_call.inputs` stanza to accept parameters. This allows consumer
repositories to specify context-specific details (e.g., the primary language,
specific build arguments, or whether a release is needed) without needing to
copy, paste, and maintain the complex underlying workflow logic.14

Target repositories will contain only minimal "caller" workflows. These simple
YAML files will primarily consist of a `jobs.*.uses` key that points to the
versioned, reusable workflow in the `platform-standards` repository, and a
`with` block to pass the required inputs. This pattern drastically reduces
maintenance overhead, and ensures that updates to CI/CD logic can be rolled out
centrally.

## 6. Scaled remediation and change management

This section addresses three practical challenges—rolling out new standards;
remediating existing non-compliance; and managing legitimate exceptions across a
large, diverse fleet of repositories.

### 6.1. The `multi-gitter` pattern for mass pull requests

When a new standard is introduced or an existing canonical file is updated
(e.g., modifying the standard `ruff.toml` to include a new rule), `multi-gitter`
will be used to automate the roll-out across all affected repositories.8

The process is as follows:

1. A remediation script is created (e.g., a shell script). This script contains
   the logic for a single repository: clone, copy the new canonical file into
   place, `git add`, and `git commit`.
1. The `multi-gitter run` command is executed, pointing to this script.
1. `multi-gitter` is configured with the organization name, and filters (e.g.,
   repository topics) to target the correct set of repositories.
1. It is also provided with a standard branch name, commit message, and pull
   request title.
1. The tool then automatically executes the script against each targeted
   repository in parallel, opening a pull request in each one that contains the
   proposed change.

This provides an efficient, auditable mechanism for proposing changes at scale,
which can then be reviewed, tested by the repository's own CI, and merged by the
respective code owners.

### 6.2. A framework for managing exemptions

In any large-scale system, absolute enforcement without a mechanism for
exceptions can be counter-productive. A formal, transparent, and time-bounded
process for managing exemptions is therefore required.

- **Mechanism:** A repository may contain a file named
  `standards-exemptions.yaml` at its root.

- **Schema:** This file must contain a list of exemption objects, where each
  object has the following keys:

- `check_id`: A string that must exactly match the ID of the check to be
  exempted, as defined in Table 3 (e.g., `PD-001`).

- `justification`: A detailed, human-readable string explaining the technical or
  business reason for the exemption. This text is crucial for auditing purposes.

- `expiry_date`: An optional date in `YYYY-MM-DD` format. If present, the
  exemption is considered invalid after this date. This encourages the
  resolution of technical debt.

- **Auditor Logic:** The Auditor will parse this file at the beginning of its
  run. If a check subsequently fails, the Auditor will consult its list of
  parsed exemptions. If a valid, non-expired exemption exists for that specific
  `check_id`, the Auditor will modify its reporting. Instead of reporting the
  finding in the SARIF file with a `level` of `error`, it will downgrade it to
  `note` or `warning`. The `justification` text from the exemption file will be
  included in the SARIF result message. This allows the overall Code Scanning
  status check to pass, unblocking the merge, while still maintaining a
  machine-readable, and human-auditable record of the acknowledged technical
  debt.

## 7. Phased implementation strategy

A pragmatic, multi-phase roll-out plan is essential to minimize disruption,
build trust with development teams, and gather feedback before enabling full
enforcement. The implementation will proceed through the following four phases.

### 7.1. Phase 1: audit, visibility, and foundational tooling (audit-only mode)

- **Goal:** To establish the complete audit, and reporting pipeline without
  blocking any developer activity, providing full visibility into the current
  state of compliance across the organization.
- **Actions:**

1. Construct the `platform-standards` repository with the initial set of
   policies, canonical files, and reusable workflows.
1. Develop, and deploy the Auditor GitHub Action. Configure it to run on a
   nightly schedule across all repositories in the organization.
1. Configure the Auditor to upload its SARIF reports, which will begin to
   populate the Code Scanning tab in each repository. This makes compliance data
   visible to repository owners.
1. Establish the OpenTofu pipeline, and configure it to run `tofu plan` nightly.
   The plan's output will be stored as an artefact, and alerts will be
   configured to notify the platform team of any detected drift. No `tofu apply`
   operations will be performed.
1. No enforcement rulesets will be created or activated.
1. The platform team will socialize the findings with development teams, publish
   a compliance "scoreboard" to track progress, and use the data to prioritize
   the most common issues.

### 7.2. Phase 2: non-blocking enforcement, and automated remediation (opt-in/warning mode)

- **Goal:** To introduce the enforcement mechanisms in a non-blocking "evaluate"
  mode and to provide developers with automated tools for easy remediation.
- **Actions:**

1. Use OpenTofu to create and apply the primary enforcement ruleset to all
   managed repositories, but with the `enforcement` attribute set to `evaluate`.
   This will cause the Auditor's status check to appear in pull requests, and
   report its status, but a failure will not block the merge.
1. Begin using `multi-gitter` to open pull requests that fix the most common ,
   and lowest-risk compliance issues identified in Phase 1 (e.g., adding a
   missing `.editorconfig`, standardizing a `Makefile`).
1. Actively solicit, and incorporate feedback from development teams to refine
   policies, improve the Auditor's messaging, and fix false positives.
1. Develop, and publish clear documentation for repository owners on how to
   interpret Auditor findings and use the provided remediation tools.

### 7.3. Phase 3: mandatory compliance and merge blocking (active enforcement)

- **Goal:** To make compliance with the defined standards a non-negotiable
  requirement for merging code to the default branch.
- **Actions:**

1. Communicate the cut-over date for active enforcement clearly and repeatedly
   to all engineering teams, providing a grace period for them to address any
   outstanding issues in their repositories.
1. Update the OpenTofu configuration for the primary ruleset, changing the
   `enforcement` attribute from `evaluate` to `active`.
1. Run `tofu apply` to activate the change across the organization.
1. The Auditor's status check now becomes a required merge gate. Pull requests
   with `error`-level compliance issues will be blocked from merging.
1. The platform team provides active, high-priority support to teams that are
   blocked, helping them to resolve issues and, where necessary, use the formal
   exemption process.

### 7.4. Phase 4: advanced capabilities, and maintenance reduction

- **Goal:** To build upon the stable core framework to add more sophisticated
  value-adding capabilities and to reduce the long-term operational load on the
  platform team.
- **Actions:**

1. Implement more advanced and context-aware checks, such as the "library guide
   parity" check (LG-001) that programmatically verifies that consumer projects
   are aligned with the documentation of the specific library versions they
   consume.
1. Identify categories of OpenTofu drift that are deemed safe for automatic
   remediation, and configure the nightly drift detection workflow to
   automatically trigger a `tofu apply` for these specific cases.
1. Develop self-service tooling, such as a command-line interface or a web
   application, that allows teams to easily onboard new repositories to the
   framework, automatically generating the initial `.concordat` file and
   creating the necessary caller workflows.

## 8. Operational, and security considerations

This section addresses the non-functional requirements for operating the
framework securely and reliably at enterprise scale.

### 8.1. Permissions model and access control

The various components of the framework require different levels of permission
to function correctly. These permissions must be carefully scoped to adhere to
the principle of least privilege.

- **OpenTofu Pipeline:** This is the most privileged component. The identity
  used to run `tofu apply` (either a GitHub App or a Personal Access Token) will
  require administrative permissions on all managed repositories and potentially
  organization-level permissions to manage teams and rulesets. This credential
  is highly sensitive and must be stored securely as an organization-level
  secret in GitHub Actions, with access strictly limited to the protected
  OpenTofu workflows.
- **Auditor action:** The Auditor itself should run with the default, read-only
  `GITHUB_TOKEN` wherever possible. This is sufficient for checking out code and
  reading most repository content. For specific checks that require elevated
  permissions (e.g., reading repository settings via the API), the workflow
  calling the Auditor may need additional read scopes (e.g., `contents: read`,
  `pull-requests: read`).
- **`multi-gitter` execution:** The token used for `multi-gitter` requires
  permissions to read repositories, create branches, and open pull requests. It
  does not require write or administrative access to the default branch.

### 8.2. Performance, scalability, and reliability

- **Auditor Performance:** The runtime of the Auditor is a critical performance
  metric, especially when it is configured to run on every pull request. The
  implementation must parallelize input/output-bound, and CPU-bound tasks where
  possible. The cost of checking out the `platform-standards` repository and the
  execution time of external tools like Vale and Scorecard must be monitored and
  optimized. Caching strategies for dependencies and tools within the GitHub
  Actions runner should be employed.
- **API Rate Limiting:** All components that interact with the GitHub API must
  be designed to operate within its rate limits. The OpenTofu GitHub provider
  has built-in retry logic to handle transient rate limit errors.9 Custom Python
  scripts used within the Auditor must implement their own exponential backoff
  and retry strategies when making API calls.
- **Scalability:** The framework is designed for scalability. The core logic is
  centralized in the `platform-standards` repository, while the context is
  decentralized via the `.concordat` manifests. The primary scaling bottleneck
  will be the total execution time of the scheduled Auditor runs across
  thousands of repositories. To mitigate this, the organization-wide scheduled
  workflow can be designed as a fan-out system, where a central workflow
  enumerates all repositories, and triggers a separate, per-repository
  `workflow_dispatch` event to run the audit in parallel across the entire fleet
  of GitHub runners.

### 8.3. System monitoring, and maintenance

- **Monitoring:** The success, failure, and duration of the Auditor and OpenTofu
  workflow runs must be continuously monitored. This data should be exported to
  a central monitoring or business intelligence tool to create dashboards that
  track overall compliance trends across the organization, identify the most
  common failures, and measure the framework's impact over time.

- **Maintenance:** The `platform-standards` repository is a critical piece of
  shared infrastructure, and must be maintained with a high degree of rigour.

- **Change Management:** All changes to policies, canonical files, or reusable
  workflows must go through a formal pull request review process.

- **Policy Testing:** OPA/Rego policies must have their own suite of unit tests,
  written using the `opa test` command. These tests must be run as a required CI
  check on all pull requests to the `platform-standards` repository to prevent
  regressions in policy logic.11

- **Versioning:** Reusable workflows must be versioned using semantic versioning
  tags (e.g., `v1`, `v1.1.0`). Consumer repositories should pin to a major
  version tag (e.g., `@v1`) to receive non-breaking updates automatically, while
  breaking changes must be introduced under a new major version (e.g., `@v2`),
  and rolled out deliberately. Using a specific commit SHA is the safest option
  for maximum stability and security.14

## Works cited

\[^4\]: OPA Conftest Basics - KodeKloud Notes, accessed on 26 October 2025,
[https://notes.kodekloud.com/docs/DevSecOps-Kubernetes-DevOps-Security/DevSecOps-Pipeline/OPA-Conftest-Basics](https://notes.kodekloud.com/docs/DevSecOps-Kubernetes-DevOps-Security/DevSecOps-Pipeline/OPA-Conftest-Basics)
\[^6\]: How Spectro Cloud uses Vale to enforce better writing in docs and
beyond, accessed on 26 October 2025,
[https://www.spectrocloud.com/blog/how-we-use-vale-to-enforce-better-writing-in-docs-and-beyond](https://www.spectrocloud.com/blog/how-we-use-vale-to-enforce-better-writing-in-docs-and-beyond)
\[^9\]: Provider: GitHub - v6.3.0 - opentofu/github - OpenTofu Registry,
accessed on 26 October 2025,
[https://search.opentofu.org/provider/opentofu/github/v6.3.0](https://search.opentofu.org/provider/opentofu/github/v6.3.0)
\[^10\]: Policy Testing, accessed on 26 October 2025,
[https://openpolicyagent.org/docs/policy-testing](https://openpolicyagent.org/docs/policy-testing)
\[^11\]: Vale documentation tests - GitLab Docs, accessed on 26 October 2025,
[https://docs.gitlab.com/development/documentation/testing/vale/](https://docs.gitlab.com/development/documentation/testing/vale/)
\[^12\]: Create reusable workflows in GitHub Actions | GitHub Resources …,
accessed on 26 October 2025,
[https://resources.github.com/learn/pathways/automation/intermediate/create-reusable-workflows-in-github-actions/](https://resources.github.com/learn/pathways/automation/intermediate/create-reusable-workflows-in-github-actions/)
\[^13\]: Reuse workflows - GitHub Docs, accessed on 26 October 2025,
[https://docs.github.com/en/actions/how-tos/reuse-automations/reuse-workflows](https://docs.github.com/en/actions/how-tos/reuse-automations/reuse-workflows)
\[^14\]: Open Source Security Foundation Scorecard, accessed on 26 October 2025,
[https://scorecard.dev/](https://scorecard.dev/)
